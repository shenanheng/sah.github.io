<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事件轮询</title>
      <link href="/2018/01/14/web/js/shi-jian-lun-xun/"/>
      <url>/2018/01/14/web/js/shi-jian-lun-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a><center>事件轮询</center></h1><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>　　主线程从<code>任务队列</code>中读取事件，这个过程是循环不断的。</p><p>　　所有任务都可以分为:<code>同步任务(都在主线程)</code>与<code>异步任务(任务队列中)</code>。</p><h2 id="运行的机制"><a href="#运行的机制" class="headerlink" title="运行的机制"></a>运行的机制</h2><ol><li><p><code>所有同步任务都在主线程上执行</code>，形成一个执行栈(每执行一条代码，向栈中压入这条代码)。</p></li><li><p><code>主线程之外，还存在一个&quot;任务队列&quot;。存放异步执行的代码，如定时器、事件监听回调函数等，进入等待状态</code>。</p></li><li><p>一旦主线程中的所有同步任务执行完毕，就会读取”任务队列”，看看里面有哪些任务。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p></li><li><p><code>主线程不断重复上面的第三步（轮询）</code>。</p></li></ol><h2 id="主线程与任务列表的示意图"><a href="#主线程与任务列表的示意图" class="headerlink" title="主线程与任务列表的示意图"></a>主线程与任务列表的示意图</h2><p><img src="/imgs/task-queue.png" alt="主线程与任务列表"></p><p><code>任务队列:执行的是先进先出</code>。</p><h2 id="Event-Loop-事件轮询"><a href="#Event-Loop-事件轮询" class="headerlink" title="Event Loop(事件轮询)"></a>Event Loop(事件轮询)</h2><p><img src="/imgs/event-loop.png" alt="事件轮询示意图"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件</title>
      <link href="/2018/01/06/web/js/shi-jian/"/>
      <url>/2018/01/06/web/js/shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a><center>事件</center></h1><h2 id="事件中的名词"><a href="#事件中的名词" class="headerlink" title="事件中的名词"></a>事件中的名词</h2><ul><li>事件目标(event target)：<code>发生的事件或与之相关的对象</code>(常见window,document,element)  </li><li>事件类型(event type)：<code>什么类型事件的字符串</code>(click,blur)</li><li>事件处理程序或事件监听程序：<code>处理或响应事件的函数</code></li><li>事件对象(event object)：特定事件相关且包含有关该事件详细信息的对象(<code>作为参数传递给处理程序的函数</code>)</li><li>事件传播:<code>(单个对象的特定事件(window对象的load事件),必须是不能传播的)</code><br>  a:事件的捕获(常用与处理鼠标的拖放)(<code>在target本身上注册的捕获处理事件不会被调用</code>)<br>  b:事件的冒泡</li></ul><h2 id="注册事件处理程序的三种方式"><a href="#注册事件处理程序的三种方式" class="headerlink" title="注册事件处理程序的三种方式"></a>注册事件处理程序的三种方式</h2><ul><li>js对象属性为事件处理程序</li></ul><pre class=" language-js"><code class="language-js">  target<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>设置html标签属性为事件处理程序</li></ul><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>send()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><ul><li>采用事件监听的形式</li></ul><pre class=" language-js"><code class="language-js">  <span class="token comment" spellcheck="true">/**   * type:事件类型   * callback:事件处理程序   * boolean:事件传播(true => 捕获; false => 冒泡) 默认值为false   */</span>  <span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>callback<span class="token punctuation">,</span>boolean<span class="token punctuation">)</span></code></pre><h2 id="事件的调用顺序"><a href="#事件的调用顺序" class="headerlink" title="事件的调用顺序"></a>事件的调用顺序</h2><ul><li>通过<code>设置对象的属性或者html属性注册的处理程序</code>一直优先调用</li><li>使用<code>addEventListener</code>注册处理程序按照它们<code>注册的顺序进行调用</code></li><li>使用<code>attachEvent()</code>可能按照<code>顺序进行调用</code>(<code>Ie8以及以前的版本才有attachEvent</code>)</li></ul><h2 id="事件相关的方法"><a href="#事件相关的方法" class="headerlink" title="事件相关的方法"></a>事件相关的方法</h2><pre class=" language-js"><code class="language-js">event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻止事件的默认行为(例如:点击超链接有跳转的行为使用这个方法就可以阻止跳转)</span></code></pre><pre class=" language-js"><code class="language-js">event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻止事件的传播</span></code></pre><h2 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h2><h3 id="1-捕获阶段"><a href="#1-捕获阶段" class="headerlink" title="1. 捕获阶段"></a>1. 捕获阶段</h3><pre><code>事件从根节点流向目标节点，途中流经各个DOM节点，在各个节点上触发捕获事件，直到达到目标点。</code></pre><h3 id="2-目标阶段"><a href="#2-目标阶段" class="headerlink" title="2. 目标阶段"></a>2. 目标阶段</h3><pre><code>事件到达目标节点时，就到了目标阶段，事件在目标节点上被触发</code></pre><h3 id="3-冒泡阶段"><a href="#3-冒泡阶段" class="headerlink" title="3. 冒泡阶段"></a>3. 冒泡阶段</h3><pre><code>事件在目标节点上触发后，不会终止，一层层向上冒，回溯到根节点。</code></pre><h4 id="事件的委托-解决事件处理程序过多"><a href="#事件的委托-解决事件处理程序过多" class="headerlink" title="事件的委托(解决事件处理程序过多)"></a>事件的委托(解决事件处理程序过多)</h4><ul><li><code>可以优化性能并且</code></li><li><code>添加进来的元素也可以绑定事件</code></li><li><code>一般在冒泡中使用</code>(冒泡兼容所有的主流的浏览器)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
