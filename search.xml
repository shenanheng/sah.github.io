<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>运算中的小技巧</title>
      <link href="/2018/06/16/web/operate/yun-suan-zhong-de-ji-qiao/"/>
      <url>/2018/06/16/web/operate/yun-suan-zhong-de-ji-qiao/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="运算中的小技巧"><a href="#运算中的小技巧" class="headerlink" title="运算中的小技巧"></a><center>运算中的小技巧</center></h1><ul><li><p>利用<code>~~</code>进行类型的转换,数字类型</p><ul><li>~~true => 1</li><li>~~false => 0</li><li>~~”” => 0</li><li>~~[] => 0</li><li>~~undefined => 0</li><li>~~!undefined  => 1</li><li>~~null  => 0</li><li>~~!null  => 1</li></ul></li><li><p>sring强制转换为数字</p><ul><li>‘32’ * 1 => 32</li><li>‘ds’ * 1 => NaN</li><li>null * 1 => 0</li><li>undefined * 1 => NaN</li><li>1 * { valueOf: ()=>’3’ } => 3</li></ul></li><li><p>用+号</p><ul><li>+’123’ => 123</li><li>+’ds’  => NaN</li><li>+’’ => 0</li><li>+null => 0</li><li>+undefined => NaN</li><li>+{ valueOf: ()=>’3’ } => 3</li></ul></li><li><p>被当做false的值</p><ul><li>false</li><li>空字符串</li><li>0</li><li>null</li><li>undefined</li><li>NaN</li></ul></li><li><p>当对象为<code>null</code>、<code>空字符串</code>、<code>undefined</code> => obj || ‘–’</p></li><li>将<code>"true"、"false"</code> => (/^true$/i).test(bool) // true或者false</li><li>某个类型<code>强制转化为boolean类型</code> => !!a</li><li>把字符串作为URI组件进行编码 => encodeURIComponent(URIstring)</li><li>对中文和特殊符号进行解码 => decodeURIComponent(URIstring)</li><li>boolean过来数组中所拥有为假的数组</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> compact <span class="token operator">=</span> arr <span class="token operator">=</span><span class="token operator">></span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [ 1, 2, 3, 'a', 's', 34 ]</span><span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"e"</span> <span class="token operator">*</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2018/06/08/designpattern/ce-lue-mo-shi/"/>
      <url>/2018/06/08/designpattern/ce-lue-mo-shi/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><center>策略模式</center></h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>　　<code>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换</code></p><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>　　<code>根据实际的场景,运用对应的策略</code></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li>策略类  => 封装了具体的算法，并负责具体的计算过程</li><li>环境类 => Context 接受客户的请求，随后把请求委托给某一个策略类</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句</li><li>提供了对开放—封闭原则的完美支持，将算法封装在独立的strategy 中，使得它们易于切换，易于理解，易于扩展</li><li>复用在系统的其他地方，从而避免许多重复的复制粘贴工作</li><li>利用组合和委托来让Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>使用策略模式会在程序中增加许多策略类者策略对象</li><li>此时strategy 要向客户暴露它的所有实现，这是违反最少知识原则的</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 场景根据不同的级别计算不同的薪资</span><span class="token keyword">let</span> bonusLevel <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> money <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">*</span> money<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> money <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> money<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  c<span class="token punctuation">:</span> money <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">3</span> <span class="token operator">*</span> money<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  d<span class="token punctuation">:</span> money <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">4</span> <span class="token operator">*</span> money<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 使用策略模式计算奖金 * @describe: 普通函数利用策略设计模式 * @param     {[type]}   money [description] 工资 * @param     {[type]}   type  [description] 哪个等级 */</span><span class="token keyword">function</span> <span class="token function">getBonus</span><span class="token punctuation">(</span>money<span class="token punctuation">,</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> bonusLevel<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> bonus <span class="token operator">=</span> <span class="token function">getBonus</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// console.log(bonus)</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2018/06/07/designpattern/dai-li-mo-shi/"/>
      <url>/2018/06/07/designpattern/dai-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><center>代理模式</center></h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>　　<code>为一个对象提供一个代用品或占位符，以便控制对它的访问</code>。(替身对象对用户的请求做出一些处理后再把请求转发给本体对象)</p><h2 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h2><p>　　用于对象应该有不同访问权限的情况</p><h2 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h2><p>　　需要代理者帮用户做一些请求(有时自己的一些请求的代价非常高,频繁的请求会造成性能问题,虚拟代理把<code>一些开销很大的对象，延迟到真正需要它的时候才去创建</code></p><h3 id="前两者的对比"><a href="#前两者的对比" class="headerlink" title="前两者的对比"></a>前两者的对比</h3><p>　　<code>保护代理用于控制不同权限的对象对目标对象的访问，但在JavaScript 并不容易实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式</code></p><h2 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h2><p>　　可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。</p><h2 id="虚拟代理中的惰性"><a href="#虚拟代理中的惰性" class="headerlink" title="虚拟代理中的惰性"></a>虚拟代理中的惰性</h2><p>　　用高阶函数动态创建代理:通过传入<code>高阶函数</code>这种更加灵活的方式，可以为各种计算方法创建缓存代理。现在这些计算方法被当作参数传入一个专门用于创建缓存代理的工厂中， 这样一来，我们就可以为乘法、加法、减法等创建缓存代理.</p><h2 id="防火墙代理"><a href="#防火墙代理" class="headerlink" title="防火墙代理"></a>防火墙代理</h2><p>　　控制网络资源的访问，保护主题不让“坏人”接近</p><h2 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h2><p>　　为一个对象在不同的地址空间提供局部代表，在Java 中，远程代理可以是另一个虚拟机中的对象。</p><h2 id="智能引用代理"><a href="#智能引用代理" class="headerlink" title="智能引用代理"></a>智能引用代理</h2><p>　　取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。</p><h2 id="写时复制代理"><a href="#写时复制代理" class="headerlink" title="写时复制代理"></a>写时复制代理</h2><p>　　通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL操作系统中的动态链接库）是其典型运用场景。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2018/06/06/designpattern/dan-li-mo-shi/"/>
      <url>/2018/06/06/designpattern/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><center>单例模式</center></h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>　　<code>判断是否有这个实例,没有就创建,有就返回它的实例</code></p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>　　<code>在整个过程中只需要一个对象,并提供全局的访问</code></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 非透明的单例 * @describe: 没有显示的new,使用者并不知道这是一个类 */</span><span class="token keyword">function</span> <span class="token function">NoTransparentSingle</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>NoTransparentSingle<span class="token punctuation">.</span>getinstance <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 这里的this指代的是构造函数</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">||</span> <span class="token keyword">new</span> <span class="token class-name">NoTransparentSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> a <span class="token operator">=</span> NoTransparentSingle<span class="token punctuation">.</span><span class="token function">getinstance</span><span class="token punctuation">(</span><span class="token string">"熊大"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> NoTransparentSingle<span class="token punctuation">.</span><span class="token function">getinstance</span><span class="token punctuation">(</span><span class="token string">"熊二"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// console.log('非透明的单例', a === b,'第一种写法',a.instance,b.instance,a,b);</span><span class="token comment" spellcheck="true">// 第二种写法 采用的是闭包的形式</span><span class="token keyword">function</span> <span class="token function">NoTransparentSingle</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>NoTransparentSingle<span class="token punctuation">.</span>getinstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    instance <span class="token operator">=</span> instance <span class="token operator">?</span> instance <span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">NoTransparentSingle</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> c <span class="token operator">=</span> NoTransparentSingle<span class="token punctuation">.</span><span class="token function">getinstance</span><span class="token punctuation">(</span><span class="token string">"熊大"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> d <span class="token operator">=</span> NoTransparentSingle<span class="token punctuation">.</span><span class="token function">getinstance</span><span class="token punctuation">(</span><span class="token string">"熊二"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// console.log('非透明的单例', c === d,'第二种写法',c,d);</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 透明的惰性单例模式 * @describe:透明 => new (证明是一个类) 惰性 => 并不是类创建的时候就创建了一个实例,而是哪里需要创建才创建一个实例 */</span><span class="token keyword">let</span> TransparentSingle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> instance<span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">TransparentSingle</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  这里进行了一系列处理</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> TransparentSingle<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransparentSingle</span><span class="token punctuation">(</span><span class="token string">"熊大"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransparentSingle</span><span class="token punctuation">(</span><span class="token string">"熊二"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// console.log('透明的单例', e === f,'第一种写法',e,f);</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 通用的单例模式 */</span><span class="token keyword">function</span> <span class="token function">generalSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> instance<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>instance <span class="token operator">=</span> instance <span class="token operator">||</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/2018/06/05/designpattern/die-dai-qi-mo-shi/"/>
      <url>/2018/06/05/designpattern/die-dai-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><center>迭代器模式</center></h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>　　指提供一种方法顺序访问一个<code>聚合对象</code>中的各个元素，而又不需要暴露该对象的内部表示</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>　　可以把<code>迭代的过程</code>从<code>业务逻辑中</code>分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p><h2 id="内部迭代器"><a href="#内部迭代器" class="headerlink" title="内部迭代器"></a>内部迭代器</h2><p>　　外界不用关心迭代器内部的实现，跟｀迭代器的交互也仅仅是一次初始调用｀，但这也刚好是内部迭代器的缺点。由于｀内部迭代器的迭代规则已经被提前规定｀</p><h2 id="外部迭代器"><a href="#外部迭代器" class="headerlink" title="外部迭代器"></a>外部迭代器</h2><p>　　必须显式地请求迭代下一个元素。但它的适用面更广，也能满足更多变的需求</p><p>　　迭代类数组对象和字面量对象、倒序迭代器、中止迭代器</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 模拟each的函数(内部迭代器的简单实现) * @param     {[type]}   arr      需要循环的数组 * @param     {Function} callback 循环后需要触发的回调 */</span><span class="token keyword">function</span> <span class="token function">each</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    callback<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> item<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 外部迭代器的简单实现 * @date      2018-10-18 * @param     {[type]}   obj  传入的对象 */</span><span class="token keyword">function</span> <span class="token function">outIterator</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> currentIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前进行到第几个</span>  <span class="token keyword">let</span> next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    currentIndex<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> isDone <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 是否已经完成</span>    <span class="token keyword">return</span> currentIndex <span class="token operator">>=</span> obj<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> getItem <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> obj<span class="token punctuation">[</span>currentIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    getItem<span class="token punctuation">,</span>    next<span class="token punctuation">,</span>    isDone  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">compare</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr1<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>arr2<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> arr2<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"不相等"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    arr1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    arr2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"相等"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 实例计算两个数组是否一样</span><span class="token keyword">let</span> oneOutIterator <span class="token operator">=</span> <span class="token function">outIterator</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> twoOutIterator <span class="token operator">=</span> <span class="token function">outIterator</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// compare(oneOutIterator,twoOutIterator);</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布-订阅者模式</title>
      <link href="/2018/06/04/designpattern/fa-bu-ding-yue-zhe-mo-shi/"/>
      <url>/2018/06/04/designpattern/fa-bu-ding-yue-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="发布-订阅者模式"><a href="#发布-订阅者模式" class="headerlink" title="发布-订阅者模式"></a><center>发布-订阅者模式</center></h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>　　它定义对象间的一种<code>一对多的依赖关系</code>，当<code>一个对象的状态发生改变</code>时，所有依赖于<code>它的对象都将得到通知</code>。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>时间上的解耦</li><li>对象之间的解耦</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>创建订阅者本身要消耗一定的时间和内存</li><li>对象与对象之间的必要联系难以跟踪与维护</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*******************发布者订阅者模式**********************************/</span><span class="token keyword">function</span> <span class="token function">Observer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 订阅者列表</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 添加订阅者订阅事件 * @param     {[type]}   event 订阅的事件名称 * @param     {[type]}   fn 订阅者的回调事件 */</span>Observer<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>listen <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 证明存在这个事件</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 删除订阅者订阅事件 * @param     {[type]}   event 订阅的事件名称 * @param     {[type]}   fn 订阅者 */</span>Observer<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>remove <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item <span class="token operator">!==</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 发布者发布信息 * @param     {[type]}   event 订阅的事件名称 * @param     {[type]}   fn 订阅者 */</span>Observer<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>trigger <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 一般第一次都为事件的类型</span>  <span class="token keyword">let</span> event <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> fns <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fns <span class="token operator">||</span> fns<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  fns<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 发送消息附带的参数</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 添加事件订阅者</span>obs<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>  <span class="token string">"send100"</span><span class="token punctuation">,</span>  <span class="token punctuation">(</span>fn1 <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"小名"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obs<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>  <span class="token string">"send100"</span><span class="token punctuation">,</span>  <span class="token punctuation">(</span>fn2 <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"小红"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obs<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"send100"</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span>obs<span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token string">"send100"</span><span class="token punctuation">,</span> <span class="token number">30000</span><span class="token punctuation">,</span> <span class="token number">400000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2018/06/04/designpattern/she-ji-mo-shi/"/>
      <url>/2018/06/04/designpattern/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><center>设计模式</center></h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>　　<code>将不变的部分和变化的部分隔开</code></p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>单一职责原则(SRP)<ul><li>一个对象（方法）<code>只做一件事情</code>  =>  应该只有一个原因而引起方法或者对象的改变</li><li>何时应该分离职责: 当跟着需求的变化,两个职责同时变化,就可以不必分离.</li></ul></li></ul><p>　　优点:降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责</p><p>　　缺点:｀最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度｀。</p><p>　　是否采用单一职责:在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。</p><ul><li>最少知识原则</li></ul><p>　　最少知识原则要求我们在设计程序时，应当尽量｀减少对象之间的交互｀。如果需要某些联系 => 常见的做法是｀引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求｀。</p><ul><li>开放封闭原则</li></ul><p>　　当需要改变一个程序的功能或者给这个程序增加新功能的时候，<code>可以使用增加代码的方式</code>，但是不允许改动程序的源代码。</p><p>　　遵守开放封闭原则(使用一些技巧)</p><ul><li><code>利用对象的多态性</code>让程序遵守开放封闭原则，是一个常用的技巧</li><li><code>放置挂钩</code> => 模板方法模式中的挂钩应用</li><li><code>回调函数</code></li></ul><h2 id="运用思想以及函数"><a href="#运用思想以及函数" class="headerlink" title="运用思想以及函数"></a>运用思想以及函数</h2><ol><li>面向对象编程</li><li>面向切面编程(aop)</li><li>鸭子类型</li><li>函数节流</li><li>函数防抖</li><li>分时函数</li><li>高阶函数</li><li>惰性加载函数</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高前端性能</title>
      <link href="/2018/05/20/web/performance/improveperformance/"/>
      <url>/2018/05/20/web/performance/improveperformance/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="提高性能"><a href="#提高性能" class="headerlink" title="提高性能"></a><center>提高性能</center></h1><h2 id="网络方面"><a href="#网络方面" class="headerlink" title="网络方面"></a>网络方面</h2><ul><li>减少dns查询时间</li><li>网络请求过程中采用cdn加速</li><li>相同的静态资源缓存</li><li>减少http请求大小</li><li>减少http请求次数(是否可以把多次请求合并成一次(需要后台的逻辑处理))</li><li>服务端渲染</li></ul><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><ul><li>延迟加载</li><li>setTimeout</li><li>让js最后加载(把js文件放入页面底部)</li><li><code>h5中script可以async属性,缺点:不能控制加载的顺序</code></li><li>如果比较大的图片可以等页面加载完成之后用window.onload的方法来加载</li></ul><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul><li>加载性能</li><li>选择器性能</li><li>渲染性能  最好把一组用公用的包裹起来.尽量减少不必要的标签(采用语义化的标签)</li><li>可维护性、健壮性(命名合理,结构层次是否健壮,样式能否抽象复用)命名最好用用元素的样式命名而不是功能命名</li><li>css的代码压缩</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源的合并与压缩</title>
      <link href="/2018/05/14/web/performance/zi-yuan-de-he-bing-yu-ya-suo/"/>
      <url>/2018/05/14/web/performance/zi-yuan-de-he-bing-yu-ya-suo/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="资源的合并与压缩"><a href="#资源的合并与压缩" class="headerlink" title="资源的合并与压缩"></a><center>资源的合并与压缩</center></h1><ul><li><code>减少http请求数量(合并)</code></li><li><p><code>减少请求资源的大小(压缩)</code></p><ul><li><p>html压缩</p><ul><li>nodejs提供html-minifier工具</li><li>后端模版引擎渲染压缩</li></ul></li><li><p>css压缩</p><ul><li>nodejs提供html-minifier工具</li><li>使用clean-css对css进行压缩</li></ul></li><li><p>JS压缩与混乱<br>　　<code>无效字符的删除,剔除注释,代码语义的缩减和优化,代码保护</code></p><ul><li>nodejs提供html-minifier工具</li><li>使用uglifyjs2对js进行压缩</li></ul></li></ul></li></ul><p>导致的问题:</p><ul><li>首屏渲染</li><li>缓存失效<br>一般公共库合并,不同页面的合并</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css与js的装载与执行</title>
      <link href="/2018/05/14/web/performance/css-yu-js-de-zhuang-zai-yu-zhi-xing/"/>
      <url>/2018/05/14/web/performance/css-yu-js-de-zhuang-zai-yu-zhi-xing/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="css与js的装载与执行"><a href="#css与js的装载与执行" class="headerlink" title="css与js的装载与执行"></a><center>css与js的装载与执行</center></h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shenanheng/pictureManage/master/blog/markdown/css-js-load-execute.png" alt="装载与执行"></p><ul><li><p>顺序执行、并发加载</p><ul><li>词法分析 => 从上到下依次解析</li><li>并发加载 => 并发加载有上限(某个域名下并发数量是有限制的,应该控制每个域名下加载的资源数量)</li></ul></li><li><p>是否阻塞</p><ul><li><p>css阻塞  </p><ul><li><code>css head中用link引入会阻塞页面的渲染(推荐)</code></li><li><code>css阻塞js的执行</code></li><li><code>不阻塞外部脚本的加载</code></li></ul></li><li><p>js阻塞</p><ul><li>直接引入的js阻塞页面的渲染</li><li>js不阻塞资源的加载</li><li>js顺序执行,阻塞后续js逻辑的执行</li></ul></li></ul></li><li><p>依赖关系</p></li><li>引入方式</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>懒加载与预加载</title>
      <link href="/2018/05/13/web/performance/lan-jia-zai-yu-yu-jia-zai/"/>
      <url>/2018/05/13/web/performance/lan-jia-zai-yu-yu-jia-zai/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="懒加载与预加载"><a href="#懒加载与预加载" class="headerlink" title="懒加载与预加载"></a><center>懒加载与预加载</center></h1><h2 id="懒加载-基本对于图片"><a href="#懒加载-基本对于图片" class="headerlink" title="懒加载(基本对于图片)"></a>懒加载(基本对于图片)</h2><ul><li>减少无效资源的加载</li><li>并发加载的资源过多会阻塞js的加载影响网站的正常使用</li><li>图片进入可是区域之后请求图片资源</li><li>电商等图片很多的情况,页面很长的业务场景适用</li></ul><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><ul><li>图片等静态资源在使用之前的提前请求</li><li>资源使用时从缓存中加载,提升用户体验</li><li>页面展示的依赖关系维护</li></ul><h3 id="预加载方式"><a href="#预加载方式" class="headerlink" title="预加载方式"></a>预加载方式</h3><ul><li>用img src属性并把这个标签标记为display:none;</li><li>let img = new Image(); img.src=’XXX’</li><li>使用ajax请求</li></ul><h2 id="图片常用的业务场景"><a href="#图片常用的业务场景" class="headerlink" title="图片常用的业务场景"></a>图片常用的业务场景</h2><ul><li>jpg有损压缩,压缩率高,不支持透明</li><li>png支持透明,浏览器兼容好</li><li>svg矢量图,代码内嵌,相对较小,图片样式相对简单的场景</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重绘与回流</title>
      <link href="/2018/05/13/web/performance/redrawreflow/"/>
      <url>/2018/05/13/web/performance/redrawreflow/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a><center>重绘与回流</center></h1><h2 id="重绘-redraw"><a href="#重绘-redraw" class="headerlink" title="重绘(redraw)"></a>重绘(redraw)</h2><ul><li><code>元素外观的改变所触发的浏览器行为</code>，例如改变visibility、outline、背景色等属性。</li><li><code>浏览器会根据元素的新属性重新绘制，使元素呈现新的外观</code>。</li><li><code>重绘不会带来重新布局，并不一定伴随重排</code>。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shenanheng/pictureManage/master/blog/markdown/redraw-element.png" alt="重绘元素"></p><h3 id="减少重绘"><a href="#减少重绘" class="headerlink" title="减少重绘"></a>减少重绘</h3><ul><li><code>将多次改变样式属性的操作合并成一次操作</code></li><li><code>经常获取那些引起浏览器重排的属性值时，要缓存到变量</code></li></ul><h2 id="重排也叫回流-reflow"><a href="#重排也叫回流-reflow" class="headerlink" title="重排也叫回流(reflow)"></a>重排也叫回流(reflow)</h2><ul><li><code>DOM元素的几何属性变化</code></li><li><code>DOM树的结构变化</code></li><li><code>获取某些属性</code></li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shenanheng/pictureManage/master/blog/markdown/reflow-element.png" alt="回流元素"></p><h3 id="减少回流"><a href="#减少回流" class="headerlink" title="减少回流"></a>减少回流</h3><ul><li><code>将需要多次重排的元素设置为absolute,例如有动画效果的元素</code></li><li><code>动态添加节点数据的时候,当全部添加完成后才进行dom的append操作</code></li><li><code>对于display:none的元素操作不会引发其他元素的重排(可以让操作很复杂的元素先进行隐藏然后在显示)</code></li></ul><h2 id="新建dom过程"><a href="#新建dom过程" class="headerlink" title="新建dom过程"></a>新建dom过程</h2><ul><li>获取DOM后分割为多个图层</li><li>对每个图层的节点计算样式结果（Recalculate style–样式重计算）</li><li>为每个节点生成图形和位置（Layout–回流和重布局）</li><li>将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘）</li><li>图层作为纹理上传至GPU</li><li>符合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组）</li></ul><h2 id="Chrome创建图层的条件"><a href="#Chrome创建图层的条件" class="headerlink" title="Chrome创建图层的条件"></a>Chrome创建图层的条件</h2><ul><li>3D或透视变换（perspective transform）CSS属性</li><li>使用加速视频解码的video节点</li><li>拥有3D（WebGL）上下文或加速的2D上下文的canvas节点</li><li>混合插件（如Flash）</li><li>对自己的opacity做CSS动画或使用一个动画webkit变换的元素</li><li>拥有加速CSS过滤器的元素</li><li>元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）</li><li>元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>用translate替代top改变 => <code>top会触发回流但是translate</code>不会 (应用:当有页面有浮窗的时候)</li><li>用opacity替代visibility => <code>visibility会触发重绘,opacity没有重绘的过程,而重绘的过程是生成图层,但是opacity实际上是直接改变图层的alpha通道</code></li><li>不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className</li><li>dom先<code>display:none</code>修改完成后再显示</li><li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量(变量在外面赋值)</li><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择</li><li>对于动画新建图层  <code>transform:translateZ(0) 或者使用transform:translate3d(0,0,0)(看情况而定是否使用)</code></li><li>启用 GPU 硬件加速</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的存储</title>
      <link href="/2018/05/13/web/performance/browserstorage/"/>
      <url>/2018/05/13/web/performance/browserstorage/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="浏览器的存储"><a href="#浏览器的存储" class="headerlink" title="浏览器的存储"></a><center>浏览器的存储</center></h1><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="生成方式-cookie"><a href="#生成方式-cookie" class="headerlink" title="生成方式(cookie)"></a>生成方式(cookie)</h3><ul><li>http response header中的set-cookie</li><li>js中可以通过document.cookie可以读写cookie</li></ul><h3 id="作用-cookie"><a href="#作用-cookie" class="headerlink" title="作用(cookie)"></a>作用(cookie)</h3><ul><li>用于浏览器端与服务器端的交互(主要用于辨别用户)</li><li>客户端自身数据的存储(逐渐用localStorage代替)</li></ul><h3 id="特性-cookie"><a href="#特性-cookie" class="headerlink" title="特性(cookie)"></a>特性(cookie)</h3><ul><li>cookie是创建于服务器端</li><li>cookie保存在浏览器端</li><li>cookie的生命周期可以通过cookie.setMaxAge(2000);来设置，如果没有设置setMaxAge,则cookie的生命周期当浏览器关闭的时候，就消亡了</li><li>cookie可以被多个同类型的浏览器共享  可以把cookie想象成一张表</li><li>cookie中在相关域名下面 —— cdn的流量损耗 <code>建议cnd的域名与主站的域名要分开</code></li></ul><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><h3 id="失效的方法"><a href="#失效的方法" class="headerlink" title="失效的方法"></a>失效的方法</h3><ul><li>关闭tomcat</li><li>reload web应用</li><li>session时间到</li><li>invalidate  session</li></ul><h2 id="cookie与session比较"><a href="#cookie与session比较" class="headerlink" title="cookie与session比较"></a>cookie与session比较</h2><ul><li><p>存在的位置</p><ul><li>cookie：存在于客户端，临时文件夹中</li><li>session：存在于服务器的内存中，一个session域对象为一个用户浏览器服务</li></ul></li><li><p>安全性</p><ul><li>cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放</li><li>session存放于服务器的内存中，所以安全性好</li></ul></li><li><p>网络传输量</p><ul><li>cookie会传递消息给服务器</li><li>session本身存放于服务器，不会有传送流量</li></ul></li><li><p>生命周期(以20分钟为例)</p><ul><li>cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束，</li><li>session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁但是，如果在20分钟内（如在第19分钟时）访问过session，那么，将重新计算session的生命周期</li><li>关机会造成session生命周期的结束，但是对cookie没有影响</li></ul></li><li><p>访问范围</p><ul><li>session为一个用户浏览器独享</li><li>cookie为多个用户浏览器共享</li></ul></li></ul><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>　　生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>　　当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。</p><h3 id="公用方法-本地缓存"><a href="#公用方法-本地缓存" class="headerlink" title="公用方法(本地缓存)"></a>公用方法(本地缓存)</h3><ul><li>setItem(key,value); // 设置某条</li><li>getItem(key);// 获取某条</li><li>removeItem(key);  // 移除单个信息</li><li>clear() // 清空所有的信息</li></ul><h3 id="不同-本地缓存"><a href="#不同-本地缓存" class="headerlink" title="不同(本地缓存)"></a>不同(本地缓存)</h3><ul><li><code>不同浏览器无法共享</code>localStorage或sessionStorage中的信息。</li><li><code>相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口）</code></li><li><code>但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</code></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求缓存</title>
      <link href="/2018/05/12/web/performance/cache/"/>
      <url>/2018/05/12/web/performance/cache/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="浏览器与服务器之间的缓存策略"><a href="#浏览器与服务器之间的缓存策略" class="headerlink" title="浏览器与服务器之间的缓存策略"></a><center>浏览器与服务器之间的缓存策略</center></h1><p>http-header可以设置缓存信息</p><ul><li><p>Cache-control取值</p><ul><li>max-age<br>　　 从请求资源到这段时间之内这个是有效的,再次发送请求的时候可以直接从缓存里面读取,(高于expires)</li><li>s-maxage<br>　　对于public(公用都能够读取)的缓存设备生效 =>例如cdn缓存设备中拿导致返回的是304而不是200</li><li>no-cache<br>　　如果 no-cache 指令没有规定 field-name，那么一个缓存不能使用响应以满足接下来的、没有与源服务器重新验证的请求。这可以让源服务器防止缓存，甚至是已被配置的缓存，返回给客户端陈旧的响应</li><li>no-store<br>　　没有任何的缓存策略</li><li>public<br>　　指示响应可以被任何缓存所缓存，即使通常它只是非可缓存或可缓存到一个非共享缓存内</li><li>private<br>　　指示响应信息的全部或部分用于单个用户，而不能用一个共享缓存来缓存</li></ul></li><li><p>expires<br>　　缓存过期时间,用来指定资源到期的时间,是服务器端的具体的时间点. 并且在这个期间浏览器可以直接从浏览器缓存取数据,而无需再次请求</p></li></ul><h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><p>上次修改时间</p><ul><li>上次修改时间</li><li>配合If-Modified-Since或者If-Unmodified-Since使用</li><li>对比上次修改时间验证资源是否需要更新</li></ul><p>缺点:</p><ol><li>某些服务端<code>不能获取精确的修改时间</code></li><li><code>文件修改时间改了,但文件内容没有变</code></li></ol><h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h2><p>数据签名</p><ul><li>典型做法：对资源内容进行hash计算</li><li>配合If-Match或者Id-Non-Match使用</li><li>对比资源的签名判断是否使用缓存</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象相等比较算法</title>
      <link href="/2018/05/05/web/operate/chou-xiang-xiang-deng-bi-jiao-suan-fa/"/>
      <url>/2018/05/05/web/operate/chou-xiang-xiang-deng-bi-jiao-suan-fa/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="抽象相等比较算法"><a href="#抽象相等比较算法" class="headerlink" title="抽象相等比较算法"></a><center>抽象相等比较算法</center></h1><p>　　比较运算x==y, 其中x和 y是值，产生true或者false</p><ul><li><p>若Type(x)与Type(y)相同， 则若x为null且y为undefined， 返回true</p><ul><li>若Type(x)为Undefined， 返回true</li><li>若Type(x)为Null， 返回true</li><li>若Type(x)为Numbe,则<ul><li><code>若x为NaN， 返回false</code></li><li><code>若y为NaN， 返回false</code></li><li>若x与y为相等数值， 返回true</li><li>若x 为 +0 且 y为−0， 返回true</li><li>若x 为 −0 且 y为+0， 返回true</li><li>返回false</li></ul></li><li>若Type(x)为String, 则当x和y为完全相同的字符序列（长度相等且相同字符在相同位置）时返回true。 否则， 返回false</li><li>若Type(x)为Boolean, 当x和y为同为true或者同为false时返回true。 否则， 返回false</li><li><code>当x和y为引用同一对象时返回true。否则，返回false</code></li></ul></li><li><p>若x为null且y为undefined， 返回true</p></li><li>若x为undefined且y为null， 返回true</li><li>若Type(x) 为 Number 且 Type(y)为String， 返回comparison x == ToNumber(y)的结果</li><li>若Type(x) 为 String 且 Type(y)为Number，返回比较ToNumber(x) == y的结果</li><li>若Type(x)为Boolean， 返回比较ToNumber(x) == y的结果</li><li>若Type(y)为Boolean， 返回比较x == ToNumber(y)的结果</li><li><code>若Type(x)为String或Number，且Type(y)为Object，返回比较x == ToPrimitive(y)的结果</code></li><li><code>若Type(x)为Object且Type(y)为String或Number， 返回比较ToPrimitive(x) == y的结果</code></li><li>返回false</li></ul><p>注:按以上相等之定义</p><ul><li>字符串比较可以按这种方式强制执行: “” + a == “” + b</li><li>数值比较可以按这种方式强制执行: +a == +b</li><li>布尔值比较可以按这种方式强制执行: !a == !b</li></ul><p>注:等值比较操作保证以下不变</p><ul><li>A != B等价于!(A==B)</li><li>A == B等价于B == A，除了A与B的执行顺序</li></ul><p>注：<code>相等运算符不总是传递的</code>。例如，<code>两个不同的String对象，都表示相同的字符串值；==运算符认为每个String对象都与字符串值相等，但是两个字符串对象互不相等</code></p><ul><li>new String(“a”) == “a” 和 “a” == new String(“a”)皆为true</li><li>new String(“a”) == new String(“a”)为false</li></ul><p>注：字符串比较使用的方式是简单地检测字符编码单元序列是否相同。不会做更复杂的、基于语义的字符或者字符串相等的定义以及Unicode规范中定义的 collating order。所以Unicode标准中认为相等的String值可能被检测为不等。实际上这一算法认为两个字符串已经是经过规范化的形式。</p><h2 id="奇特的等值"><a href="#奇特的等值" class="headerlink" title="奇特的等值"></a>奇特的等值</h2><ul><li>undefined == null  ===> true</li><li>null == null 与null === null 与undefined == undefined与undefined=== undefined都是 true</li><li>[] == ![]  ===> true<br>　　过程:[]==![]  —->   []==false   —–>   0==0   —>//true</li><li>NaN == NaN 与 NaN == NaN===> false</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域请求</title>
      <link href="/2018/04/29/web/httprequest/crossdomainrequest/"/>
      <url>/2018/04/29/web/httprequest/crossdomainrequest/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a><center>跨域请求</center></h1><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>　　<code>同源策略</code>:是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现</p><p>　　<code>同源</code>:指代域名(<code>www.wikipedia.org</code> => 指向<code>208.80.152.2</code>,当我们输入<a href="http://www.wikipedia.org时dns会帮我们解析成208.80.152.2)，协议(如http,https)，端口(如8080)相同" target="_blank" rel="noopener">www.wikipedia.org时dns会帮我们解析成208.80.152.2)，协议(如http,https)，端口(如8080)相同</a></p><h2 id="不受同源策略限制"><a href="#不受同源策略限制" class="headerlink" title="不受同源策略限制"></a>不受同源策略限制</h2><ul><li>页面中的链接，重定向以及表单提交是不会受到同源策略限制的</li><li>跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的script、img、link、iframe等</li></ul><h2 id="跨域的解决"><a href="#跨域的解决" class="headerlink" title="跨域的解决"></a>跨域的解决</h2><h3 id="document-domain属性"><a href="#document-domain属性" class="headerlink" title="document.domain属性"></a>document.domain属性</h3><p>　　支持多域名站点,使用的字符串必须具有有效的域前缀或它本身,domain值中必须有一个点号</p><p>　　例如:来自home.example.com的文档里的脚本想要合法的读取developer.example.com载入的文档的属性就可以把document.domain = ‘example.com’</p><h4 id="特点-domain"><a href="#特点-domain" class="headerlink" title="特点(domain)"></a>特点(domain)</h4><ul><li><code>只能在父域名与子域名之间使用</code>，且将 xxx.child1.a.com域名设置为a.com后，不能再设置成child1.a.com。</li><li><code>存在安全性问题，当一个站点被攻击后，另一个站点会引起安全漏洞</code></li><li><code>这种方法只适用于 Cookie 和 iframe 窗口</code></li></ul><h3 id="JSONP-使用script元素作为ajax传输的技术"><a href="#JSONP-使用script元素作为ajax传输的技术" class="headerlink" title="JSONP:使用script元素作为ajax传输的技术"></a>JSONP:使用script元素作为ajax传输的技术</h3><p>　　例如:a.com/jsonp.html想得到b.com/main.js中的数据</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">addScriptTag</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> <span class="token string">"text/javascript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  script<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">addScriptTag</span><span class="token punctuation">(</span><span class="token string">"http://b.com/main.js?callback=foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 请求地址</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//window.onload是为了让页面加载完成后再执行</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"欢迎您"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="特点-JSONP"><a href="#特点-JSONP" class="headerlink" title="特点(JSONP)"></a>特点(JSONP)</h4><ul><li>只能使用<code>Get</code>请求</li><li>不能<code>注册success、error</code>等事件监听函数，不能很容易的确定JSONP请求是否失败</li><li><code>JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保</code></li></ul><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>　　Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范\</p><ul><li>服务器一般需要增加如下响应头的一种或几种<ul><li>Access-Control-Allow-Origin: *</li><li>Access-Control-Allow-Methods: POST, GET, OPTIONS</li><li>Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</li><li>Access-Control-Max-Age: 86400</li></ul></li><li>跨域请求默认不会携带Cookie信息,如果需要携带，请配置下述参数<ul><li>“Access-Control-Allow-Credentials”: true</li><li>“withCredentials”: true // Ajax设置</li></ul></li></ul><h3 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name+iframe"></a>window.name+iframe</h3><h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage()"></a>window.postMessage()</h3><h3 id="nginx反向代理接口跨域"><a href="#nginx反向代理接口跨域" class="headerlink" title="nginx反向代理接口跨域"></a>nginx反向代理接口跨域</h3></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传文件</title>
      <link href="/2018/04/25/web/httprequest/uploadfile/"/>
      <url>/2018/04/25/web/httprequest/uploadfile/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a><center>上传文件</center></h1><h2 id="form表单提交"><a href="#form表单提交" class="headerlink" title="form表单提交"></a>form表单提交</h2><pre class=" language-html"><form action="url" method="get" enctype="application/x-www-form-urlencoded"><code class="language-html"><form action="url" method="get" enctype="application/x-www-form-urlencoded">    <input type="text" name="input1" value="123456" />    <input type="text" name="input2" value="abcdefg" />    <button type="submit">提交</button></form></code></pre><ul><li>post请求,则会把name里面的值通过json字符串传入到后台</li><li>post请求中包含的文件上传enctype=”multipart/form-data”</li></ul><h2 id="ajax上传文件"><a href="#ajax上传文件" class="headerlink" title="ajax上传文件"></a>ajax上传文件</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>request<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"readystatechange"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>evnent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 这里要做判断</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>request<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"post"</span><span class="token punctuation">,</span> <span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> formdata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建formData</span><span class="token keyword">let</span> inputs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inputs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> input <span class="token operator">=</span> inputs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">"file"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    formdata<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">,</span> input<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 假如input的类型都是text</span>    formdata<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>name<span class="token punctuation">,</span> input<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// send()会自动设置Content-Type头</span>request<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>formdata<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求头、响应</title>
      <link href="/2018/04/25/web/httprequest/ajaxheaddetail/"/>
      <url>/2018/04/25/web/httprequest/ajaxheaddetail/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="请求头、响应"><a href="#请求头、响应" class="headerlink" title="请求头、响应"></a><center>请求头、响应</center></h1><h2 id="请求头的参数的详情"><a href="#请求头的参数的详情" class="headerlink" title="请求头的参数的详情"></a>请求头的参数的详情</h2><ul><li><p>Accept:浏览器端可以接受的媒体类型</p><ul><li>Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档,如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)</li><li>*代表任意类型 例如 Accept: / 代表浏览器可以处理所有类型(一般浏览器发给服务器都是发这个)</li></ul></li><li><p>Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）</p></li><li><p>Accept-Language:浏览器申明自己接收的语言。</p></li><li><p>Connection</p><ul><li>Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</li><li>Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li></ul></li><li><p>Host:（发送请求时，该报头域是必需的）请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p><ul><li>Host：<a href="http://www.hzau.edu.cn" target="_blank" rel="noopener">www.hzau.edu.cn</a> 此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</li></ul></li><li><p>Referer:当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。</p></li><li><p>User-Agent:告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p></li><li><p>Cookie:用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见）</p></li><li><p>Content-Type</p><ul><li>application/x-www-form-urlencoded(数据被编码为名称/值对。这是标准的编码格式)</li><li>multipart/form-data(数据被编码为一条消息，页上的每个控件对应消息中的一个部分)</li><li>text/plain(数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符)</li><li>例如<ul><li>form的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded。</li><li>当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&name2=value2…），然后把这个字串追加到url后面，用?分割，加载这个新的url。</li><li>当action为post时候，浏览器把form数据封装到http body中，然后发送到server。 如果没有type=file的控件，用默认的application/x-www-form-urlencoded就可以了。 但是如果有type=file的话，就要用到multipart/form-data了。</li><li>当action为post且Content-Type类型是multipart/form-data，浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件name)等信息，并加上分割符(boundary)。</li></ul></li></ul></li></ul><h3 id="常见的媒体格式类型"><a href="#常见的媒体格式类型" class="headerlink" title="常见的媒体格式类型"></a>常见的媒体格式类型</h3><ul><li>text/html:HTML格式</li><li>text/plain:纯文本格式  </li><li>text/xml:XML格式</li><li>image/gif:gif图片格式</li><li>image/jpeg:jpg图片格式</li><li>image/png:png图片格式</li></ul><h3 id="以application开头的媒体格式类型"><a href="#以application开头的媒体格式类型" class="headerlink" title="以application开头的媒体格式类型"></a>以application开头的媒体格式类型</h3><ul><li>application/xhtml+xml:XHTML格式</li><li>application/xml:XML数据格式</li><li>application/atom+xml:Atom XML聚合格式</li><li>application/json:JSON数据格式</li><li>application/pdf:pdf格式</li><li>application/msword:Word文档格式</li><li>application/octet-stream:二进制流数据（如常见的文件下载）</li><li>application/x-www-form-urlencoded:form属性中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）  </li></ul><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>　　一个完整的HTTP响应由<code>状态码</code>、<code>响应头集合</code>和<code>响应主体组成</code></p><ul><li>状态码:XMLHttpRequest.status获取到(200,404)等,还可以通过statusText属性获取到(OK)</li><li>响应头集合:XMLHttpRequest.getResponseHeader()和XMLHttpRequest.getAllResponseHeaders()获取响应头返回集但是过滤掉cookie头</li><li>响应主体:XMLHttpRequest.responseText属性中得到文本形式,XMLHttpRequest.responseXML属性中获取document形式</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax</title>
      <link href="/2018/04/24/web/httprequest/ajax/"/>
      <url>/2018/04/24/web/httprequest/ajax/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a><center>ajax</center></h1><h2 id="ajax流程"><a href="#ajax流程" class="headerlink" title="ajax流程"></a>ajax流程</h2><h3 id="第一步-创建XMLHttpRequest对象"><a href="#第一步-创建XMLHttpRequest对象" class="headerlink" title="第一步 创建XMLHttpRequest对象"></a>第一步 创建XMLHttpRequest对象</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="第二步-监听XMLHttpRequest对象里面的readystatechang"><a href="#第二步-监听XMLHttpRequest对象里面的readystatechang" class="headerlink" title="第二步 监听XMLHttpRequest对象里面的readystatechang"></a>第二步 监听XMLHttpRequest对象里面的readystatechang</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 用的属性监听</span><span class="token comment" spellcheck="true">/**request.onreadystatechange = function() {  console.log(request.readyState);};*/</span><span class="token comment" spellcheck="true">// 用事件监听</span><span class="token comment" spellcheck="true">/** * 当open的第三个参数的值为false的时候,这里面只能监听到1状态和4状态; * 当为true的时候能监听到1-4的状态 **/</span>request<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>  <span class="token string">"readystatechange"</span><span class="token punctuation">,</span>  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 表示open()尚未调用</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 表示open()已调用</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 接收到头信息</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 接收到相应主体</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 响应完成</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="第三步-调用XMLHttpRequest-open方法"><a href="#第三步-调用XMLHttpRequest-open方法" class="headerlink" title="第三步 调用XMLHttpRequest.open方法"></a>第三步 调用XMLHttpRequest.open方法</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param method get || post * @param url 请求地址 * @param async true || false 默认为true **/</span>request<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置请求头</span>request<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"text/plain;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="第四步-启动请求"><a href="#第四步-启动请求" class="headerlink" title="第四步: 启动请求"></a>第四步: 启动请求</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 当请求为get请求的时候是没有请求主体的request.send(null) * 当请求为post请求的时候是有请求主体的,可以传入JSON字符串 **/</span>request<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'你好'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="服务器返回的状态码"><a href="#服务器返回的状态码" class="headerlink" title="服务器返回的状态码"></a>服务器返回的状态码</h2><ul><li>200：服务器响应正常。</li><li>302：请求的资源临时从不同的 URI响应请求。(资源临时重定向)</li><li><code>304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）</code>。</li><li><code>400：a:语义有误;b:请求参数错误</code></li><li><code>401：当前请求需要用户验证或者token过期</code></li><li><code>403：没有权限访问资源。</code></li><li>404：需要访问的资源不存在。</li><li><code>405：请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。</code></li><li>407：访问的资源需要代理身份验证。</li><li><code>414：请求的URL太长。</code></li><li>500：服务器内部错误。</li></ul><h2 id="监听不同阶段触发不同类型的事件"><a href="#监听不同阶段触发不同类型的事件" class="headerlink" title="监听不同阶段触发不同类型的事件"></a>监听不同阶段触发不同类型的事件</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 进行5000秒超时会进入(timeout的钩子函数)</span>request<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这个方法看你在某个事件断调用这样的话请求就会被中止,此刻readystate就会为0并且调用onabort的钩子函数</span>request<span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当调用send的时候就会触发这个事件(1 => open被调用时)</span>request<span class="token punctuation">.</span>onloadstart <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 当正在加载服务器响应的时候(有可能不会触发 3=> 返回响应主体)</span>request<span class="token punctuation">.</span>onprogress <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 开始执行上传文件(1 => open被调用时)</span>request<span class="token punctuation">.</span>upload<span class="token punctuation">.</span>onloadstart <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ProgressEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 监测文件上传的进度(1 => open被调用时)</span>request<span class="token punctuation">.</span>upload<span class="token punctuation">.</span>onprogress  <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ProgressEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 事件完成(4 => 响应完成 但是最后返回的status不一定是200)</span>request<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 网络错误</span>request<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 请求超时</span>request<span class="token punctuation">.</span>ontimeout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 请求中止(这个时候readystate = 0 => open未被调用)</span>request<span class="token punctuation">.</span>onabort <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h2 id="输入url到呈现网页的全过程"><a href="#输入url到呈现网页的全过程" class="headerlink" title="输入url到呈现网页的全过程"></a>输入url到呈现网页的全过程</h2><ul><li>三大区块<ol><li>客户端</li><li>网络传输层</li><li>服务端</li></ol></li></ul><p>　　客户端对url判断和劫持 => 本地host文件的判断 => dns的解析 => 发送请求 =>  建立tcp连接 => 服务器响应请求 => 显示页面</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex</title>
      <link href="/2018/04/15/web/css/flex/"/>
      <url>/2018/04/15/web/css/flex/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a><center>flex</center></h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>　　采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</p><p>　　块状元素display:flex;行内元素display:inline-flex。<br>　　<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shenanheng/pictureManage/master/blog/markdown/flex.png" alt="示意图"></p><p>　　容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>　　项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>　　flex-direction定义某个轴了主轴的话,那么另外的一个轴就是交叉轴</p><ul><li><p>flex-direction 主轴的方向即项目排列方向</p><ul><li>主轴为水平方向:row  <=> row-reverse  起点分别在左边与右边</li><li>主轴为垂直方向:column <=> column-reverse 起点分别在上边与下边</li></ul></li><li><p>flex-wrap 默认情况下,项目都排在一条线上当轴线排不了时</p><ul><li>nowrap => 不换行</li><li>wrap  <=> wrap-reverse 换行,第一行在下方</li></ul></li><li><p>flex-flow</p><ul><li>flex-direction(第一个参数主轴的方向)</li><li>flex-wrap(第二个参数如果项目超出宽度时是否换行)</li></ul></li><li><p>justify-content 主轴上的对齐方式{假设主轴为从左到右}</p><ul><li>flex-start <=> flex-end (左对齐或者右对齐)</li><li>center (居中)</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></li><li><p>align-items 项目在交叉轴上如何对齐</p><ul><li>flex-start <=> flex-end</li><li>center(居中)</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch(如果项目未设置高度或设为auto，将占满整个容器的高度)</li></ul></li><li><p>align-content 定义了多跟轴线的对齐方式,如果只有一根轴的话这个属性不起作用</p><ul><li>flex-start <=> flex-end</li><li>center</li><li>stretch</li><li>space-between</li><li>space-around</li></ul></li></ul><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><ul><li>order 数值越小排列越靠前默认为0</li><li>flex-grow  定义项目的放大比例,默认为0,即如果存在剩余空间,也不放大<ul><li>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。</li><li>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</li></ul></li><li>flex-shrink 定义项目的缩小比例,默认为1,如果空间不足,该项目将缩小<ul><li>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。</li><li>如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</li></ul></li><li><p>flex-basis 分配多余的空间之前,项目占据的主轴的空间</p><ul><li>flex-basis:auto || 可以设置宽度高度</li></ul></li><li><p>flex</p><ul><li>flex: none | [ <’flex-grow’> <’flex-shrink’>? || <’flex-basis’> ]</li><li>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)</li><li>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。<br>align-self(用于搞定单个项目与别的不同)</li></ul></li><li><p>align-self</p><ul><li>align-self: auto | flex-start | flex-end | center | baseline | stretch;</li></ul></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC、IFC、GFC、FFC</title>
      <link href="/2018/04/13/web/css/bfc-ifc-gfc-ffc/"/>
      <url>/2018/04/13/web/css/bfc-ifc-gfc-ffc/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="BFC、IFC、GFC、FFC"><a href="#BFC、IFC、GFC、FFC" class="headerlink" title="BFC、IFC、GFC、FFC"></a><center>BFC、IFC、GFC、FFC</center></h1><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="概念-BFC"><a href="#概念-BFC" class="headerlink" title="概念(BFC)"></a>概念(BFC)</h3><p>　　<code>"块级格式化上下文"</code>。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p><h3 id="规则-BFC"><a href="#规则-BFC" class="headerlink" title="规则(BFC)"></a>规则(BFC)</h3><ul><li>内部的Box会在垂直方向，一个接一个地放置</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ul><h3 id="产生-BFC"><a href="#产生-BFC" class="headerlink" title="产生(BFC)"></a>产生(BFC)</h3><ul><li>float的值不为none。</li><li><code>overflow的值不为visible。(这个是最推荐开启bfc的,副作用最小)</code></li><li>position的值不为relative和static。</li><li>display的值为table-cell, table-caption, inline-block中的任何一个。</li></ul><h3 id="使用场景-BFC"><a href="#使用场景-BFC" class="headerlink" title="使用场景(BFC)"></a>使用场景(BFC)</h3><ul><li>自适应两栏布局</li><li>清除内部浮动</li><li>防止margin重叠</li></ul><h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><h3 id="概念-IFC"><a href="#概念-IFC" class="headerlink" title="概念(IFC)"></a>概念(IFC)</h3><p>　　<code>"内联格式化上下文"</code>，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)<br>　　IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。</p><h3 id="规则-IFC"><a href="#规则-IFC" class="headerlink" title="规则(IFC)"></a>规则(IFC)</h3><ul><li>盒子一个接一个地水平摆放，当容器宽度不够时就会换行</li><li>在水平方向上，这些盒的外边距、边框、内边距所占用的空间都会被计算，但行内盒的垂直的border，padding 与 margin 都不会撑开行盒的高度</li><li>在垂直方向上，这些盒可能会以不同形式来对齐，可通过 vertical-align 来设置，默认对齐为 baseline</li><li>每一行将生成一个行盒（line box），包括该行所有的盒子，行盒的宽度是由包含块和存在的浮动来决定</li><li>行盒一般左右边都贴紧其包含块，但是会因为浮动盒（float 元素）的存在而发生变化。浮动盒会位于包含块边缘与行盒边缘之间，这样行盒的可用宽度就小于包含块的宽度</li><li>当所有盒的总宽度小于行盒的宽度，那么行盒中的水平方向排版由 text-align 属性来决定</li><li>当所有盒的总宽度超过一个行盒时，就会形成多个行盒，多个行盒相互之间垂直方向不能分离，不能重叠</li><li>当一个行内盒超过行盒的宽度时，它会被分割成多个盒，这些盒被分布在多个行盒里。如果一个行内盒不能被分割（比如只包含单个字符，或word-breaking机制被禁用，或该行内框受white-space属性值为nowrap或pre的影响），那么这个行内盒将溢出这个行盒</li><li>当一个行内盒发生分割时，分割处的 margins, borders 和 padding 不会有任何视觉效果（或者其他任何分裂，只要是有多个行盒）</li><li>行盒的高度由内部元素中实际高度最高的元素计算出来。每个行盒的高度由于内容不一样，所以高度也可能不一样</li><li>在一个行盒中，当他包含的内部容器的高度小于行盒的高度的时候，内部容器的垂直位置可由自己的 vertical-align 属性来确定</li></ul><p>　　注：<code>在 IFC 的环境中，是不能存在块级元素的，如果将块级元素插入到 IFC 中，那么此 IFC 将会被破坏掉变成 BFC，而块级元素前的元素或文本和块级元素后的元素或文本将会各自自动产生一个匿名块盒其包围。</code></p><h3 id="使用场景-IFC"><a href="#使用场景-IFC" class="headerlink" title="使用场景(IFC)"></a>使用场景(IFC)</h3><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</li><li>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li></ul><h2 id="GFC"><a href="#GFC" class="headerlink" title="GFC"></a>GFC</h2><h3 id="概念-GFC"><a href="#概念-GFC" class="headerlink" title="概念(GFC)"></a>概念(GFC)</h3><p>　　<code>"网格布局格式化上下文"</code>又称网格布局(display:grid )</p><h2 id="FFC"><a href="#FFC" class="headerlink" title="FFC"></a>FFC</h2><h3 id="概念-FFC"><a href="#概念-FFC" class="headerlink" title="概念(FFC)"></a>概念(FFC)</h3><p>   <code>"自适应格式化上下文"</code>(display:flex)</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>margin</title>
      <link href="/2018/04/13/web/css/margin/"/>
      <url>/2018/04/13/web/css/margin/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="margin"><a href="#margin" class="headerlink" title="margin"></a><center>margin</center></h1><h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p>　　取值顺序一般是<code>上、右、下、左</code></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 上10 右5 下15 左20 */</span><span class="token selector">div</span><span class="token punctuation">{</span>  <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">10</span>px <span class="token number">5</span>px <span class="token number">15</span>px <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 上10 右5 下15 左5 */</span><span class="token selector">div</span><span class="token punctuation">{</span>  <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">10</span>px <span class="token number">5</span>px <span class="token number">15</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 上10 右5 下10 左5 */</span><span class="token selector">div</span><span class="token punctuation">{</span>  <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">10</span>px <span class="token number">5</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 都是10 */</span><span class="token selector">div</span><span class="token punctuation">{</span>  <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">10</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="margin的特性"><a href="#margin的特性" class="headerlink" title="margin的特性"></a>margin的特性</h2><h3 id="块级元素的垂直相邻外边距会合并"><a href="#块级元素的垂直相邻外边距会合并" class="headerlink" title="块级元素的垂直相邻外边距会合并"></a>块级元素的垂直相邻外边距会合并</h3><p>　　外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距，而行内元素实际上不占上下外边距。<code>行内元素的的左右外边距不会合并</code>。同样地，<code>浮动元素的外边距也不会合并</code>。<code>允许指定负的外边距值，不过使用时要小心</code>。</p><p>　　外边距合并的取值:<code>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者</code>。如果发生合并的<code>外边距不全是正值，则会拉近2个块级元素的垂直距离</code>，甚至会发生重叠现象<code></code></p><h3 id="发生的场景"><a href="#发生的场景" class="headerlink" title="发生的场景"></a>发生的场景</h3><ul><li>当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。</li><li>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。</li><li>外边距甚至可以与自身发生合并</li></ul><h3 id="解决的方案"><a href="#解决的方案" class="headerlink" title="解决的方案"></a>解决的方案</h3><ul><li>为父元素设置padding</li><li>为父元素或子元素设置border</li><li>在子元素前加入一个不是空的元素</li><li>为父元素或子元素声明浮动或者绝对定位</li><li><code>为父元素应用overflow：hidden属性（推荐）</code></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>methods</title>
      <link href="/2018/04/06/web/compatible/fang-fa-de-bu-jian-rong/"/>
      <url>/2018/04/06/web/compatible/fang-fa-de-bu-jian-rong/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="方法的不兼容"><a href="#方法的不兼容" class="headerlink" title="方法的不兼容"></a><center>方法的不兼容</center></h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>　　解决IE、firefox浏览器下JS的new Date()的值为Invalid Date、NaN-NaN的问题</p><ul><li><p>所有浏览器支持的格式</p><ul><li>new Date(<code>2011, 01, 07</code>); // yyyy, mm-1, dd</li><li>new Date(<code>2011, 01, 07, 11, 05, 00</code>); // yyyy, mm-1, dd, hh, mm, ss</li><li>new Date(<code>"02/07/2011"</code>); // “mm/dd/yyyy”</li><li>new Date(<code>"02/07/2011 11:05:00"</code>); // “mm/dd/yyyy hh:mm:ss”</li><li>new Date(<code>1297076700000</code>); // milliseconds</li><li>new Date(<code>"Mon Feb 07 2011 11:05:00 GMT"</code>); // “”Day Mon dd yyyy hh:mm:ss GMT/UTC</li></ul></li><li><p>采用<code>date.replace(new RegExp(/-/gm) ,"/")</code>;</p></li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//却返回这个值Invalid Date，转换失败</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">'2016-01-01 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">'2016.01.01 00:00:00'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> compatible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>forEach、map、some、every</title>
      <link href="/2018/03/31/web/js/array/foreach-map-some-every/"/>
      <url>/2018/03/31/web/js/array/foreach-map-some-every/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="forEach、map、some、every"><a href="#forEach、map、some、every" class="headerlink" title="forEach、map、some、every"></a><center>forEach、map、some、every</center></h1><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><ul><li>break,return是无法跳出循环</li><li>没有任何的返回 undefined</li></ul><h3 id="终止forEach"><a href="#终止forEach" class="headerlink" title="终止forEach"></a>终止forEach</h3><ul><li>在forEach中使用<code>break并不能终止循环</code></li><li>return false 只是<code>下面的代码不能执行而已</code></li><li>终止循环的操作<code>采用抛出异常</code></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">try</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 执行到第2次，结束循环</span>  array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"中止循环"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>message <span class="token operator">!=</span> <span class="token string">"EndIterative"</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul><li>返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值</li><li>方法按照原始数组元素顺序依次处理元素</li><li><code>不会对空数组进行检测</code></li><li><code>不会改变原始数组</code></li></ul><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><ul><li>方法用于检测数组中的元素是否满足指定条件（函数提供）</li><li>方法会依次执行数组的每个元素<ul><li>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测</li><li>如果没有满足条件的元素，则返回false</li></ul></li><li><code>不会对空数组进行检测</code></li><li><code>不会改变原始数组</code></li></ul><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><ul><li>方法用于检测数组所有元素是否都符合指定条件（通过函数提供）</li><li>方法使用指定函数检测数组中的所有元素<ul><li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测</li><li>如果所有元素都满足条件，则返回 true</li><li><code>不会对空数组进行检测</code></li><li><code>不会改变原始数组</code></li></ul></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reduce</title>
      <link href="/2018/03/31/web/js/array/reduce/"/>
      <url>/2018/03/31/web/js/array/reduce/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><center>reduce</center></h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param {callback} 执行数组中每个值的函数，包含四个参数 *  1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue）） *  2、currentValue （数组中当前被处理的元素） *  3、index （当前元素在数组中的索引） *  4、array （调用 reduce 的数组 * @param  {initialValue} 这个最好写,当数组为空的时候要报错    结论：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。 */</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token punctuation">[</span>initialValue<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ul><li>计算数组中每个元素出现的次数</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Tiff"</span><span class="token punctuation">,</span> <span class="token string">"Bruce"</span><span class="token punctuation">,</span> <span class="token string">"Alice"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> nameNum <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> cur<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token keyword">in</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span>    pre<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    pre<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> pre<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>数组去重</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> cur<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> pre<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3, 4]</span></code></pre><p>— 将二维数组转化为一维</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> cur<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> pre<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [0, 1, 2, 3, 4, 5]</span></code></pre><ul><li>将多维数组转化为一维</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>    <span class="token punctuation">(</span>pre<span class="token punctuation">,</span> cur<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> pre<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">newArr</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">:</span> cur<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">newArr</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[0, 1, 2, 3, 4, 5, 6, 7]</span></code></pre><ul><li>对象里的属性求和</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span>    subject<span class="token punctuation">:</span> <span class="token string">"math"</span><span class="token punctuation">,</span>    score<span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    subject<span class="token punctuation">:</span> <span class="token string">"chinese"</span><span class="token punctuation">,</span>    score<span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    subject<span class="token punctuation">:</span> <span class="token string">"english"</span><span class="token punctuation">,</span>    score<span class="token punctuation">:</span> <span class="token number">30</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> sum <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> cur<span class="token punctuation">.</span>score <span class="token operator">+</span> prev<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//60</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块的加载</title>
      <link href="/2018/03/24/web/module/moduleload/"/>
      <url>/2018/03/24/web/module/moduleload/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="模块的加载"><a href="#模块的加载" class="headerlink" title="模块的加载"></a><center>模块的加载</center></h1><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>　　AMD(异步模块定义) 被requireJS，NodeJs，Dojo，JQuery使用</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param name  模块标识，可以省略 * @param dependencyModule 所依赖的模块,可以省略 * @param moduleFactoryOrObject 模块的实现，或者一个JavaScript对象 * 执行过程: *     1:会异步调用第二个参数中所列出的模块 *     2:当所有模块被载入完成后 *     3:执行第三个参数回调 **/</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"module-name"</span><span class="token punctuation">;</span><span class="token keyword">var</span> dependencyModule <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> moduleFactoryOrObject <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">define</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> dependencyModule<span class="token punctuation">,</span> moduleFactoryOrObject<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 匿名模块 * 这个时候文件名就是模块名 => 模块高度可重用 **/</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><ul><li>值是动态更新</li><li>在编译的时候就执行了(所以不能使用表达式和变量 =>这个在运行时才得到结果)</li><li>导出(可以使用as修改别名)</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">var</span> firstName <span class="token operator">=</span> <span class="token string">'Michael'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">var</span> lastName <span class="token operator">=</span> <span class="token string">'Jackson'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">var</span> year <span class="token operator">=</span> <span class="token number">1958</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等价于</span><span class="token keyword">const</span> firstName <span class="token operator">=</span> <span class="token string">'Michael'</span><span class="token punctuation">;</span><span class="token keyword">const</span>  lastName <span class="token operator">=</span> <span class="token string">'Jackson'</span><span class="token punctuation">;</span><span class="token keyword">const</span>  year <span class="token operator">=</span> <span class="token number">1958</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 提倡使用这中方法</span><span class="token keyword">export</span> <span class="token punctuation">{</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span> year <span class="token keyword">as</span> time<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 默认导出 * defalult =>对外输出的接口 **/</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>firstName<span class="token punctuation">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span>lastName<span class="token punctuation">:</span> <span class="token string">'bbb'</span><span class="token punctuation">}</span></code></pre><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><ul><li>在编译的时候就执行了(所以不能使用表达式和变量 => 这个在运行时才得到结果)</li><li>不准许在加载模块的脚本里面,改写接口</li><li>如果某个接口是对象的话,就准许修改对象的属性(建议不要这样搞)</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 没有大括号,随便命名</span><span class="token keyword">import</span>  name <span class="token keyword">from</span> <span class="token string">'.........'</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token punctuation">{</span>firstName <span class="token keyword">as</span> surName<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span> time<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'......'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 整体模块的加载</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> info <span class="token keyword">from</span> <span class="token string">'.......'</span><span class="token punctuation">(</span>可以采用info<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> module </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域、作用域链、闭包</title>
      <link href="/2018/03/18/web/js/basics/zuo-yong-yu-zuo-yong-yu-lian-bi-bao/"/>
      <url>/2018/03/18/web/js/basics/zuo-yong-yu-zuo-yong-yu-lian-bi-bao/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="作用域、作用域链、闭包"><a href="#作用域、作用域链、闭包" class="headerlink" title="作用域、作用域链、闭包"></a><center>作用域、作用域链、闭包</center></h1><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ul><li>在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shenanheng/pictureManage/master/blog/markdown/execution-context.png" alt="作用域链"></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li><code>函数可以创建作用域</code></li><li><code>作用域在函数定义时就已经确定了。而不是在函数调用时确定</code></li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shenanheng/pictureManage/master/blog/markdown/scope-chain.png" alt="作用域链"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型、原型链</title>
      <link href="/2018/03/17/web/js/basics/yuan-xing-yuan-xing-lian/"/>
      <url>/2018/03/17/web/js/basics/yuan-xing-yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><center>原型链</center></h1><h2 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h2><ul><li>每个对象都有一个<code>__proto__</code>属性，指向创建该对象的函数的<code>prototype</code></li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shenanheng/pictureManage/master/blog/markdown/prototype-chain.png" alt="原型链"></p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2018/03/11/web/js/basics/ji-cheng/"/>
      <url>/2018/03/11/web/js/basics/ji-cheng/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a><center>继承</center></h1><h2 id="原型链的继承"><a href="#原型链的继承" class="headerlink" title="原型链的继承"></a>原型链的继承</h2><ul><li>核心:将父类的实例作为子类的原型</li><li><p>优点</p><ul><li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li><li>父类新增原型方法/原型属性，子类都能访问到</li><li>简单，易于实现</li></ul></li><li><p>缺点</p><ul><li>要想为子类新增属性和方法，必须要在new Father()这样的语句之后执行，不能放到构造器中</li><li>无法实现多继承</li><li>来自原型对象的引用属性是所有实例共享的</li><li>创建子类实例时，无法向父类构造函数传参</li></ul></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"儿子"</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>study <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我在学习"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Son<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Son<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>playing <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"打篮球"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h2><ul><li>核心:使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</li><li><p>优点</p><ul><li>解决了原型链继承中，子类实例共享父类引用属性的问题</li><li>创建子类实例时，可以向父类传递参数</li><li>可以实现多继承（call多个父类对象</li></ul></li><li><p>缺点</p><ul><li>实例并不是父类的实例，只是子类的实例</li><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li></ul></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Father<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">"son"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="实例继承"><a href="#实例继承" class="headerlink" title="实例继承"></a>实例继承</h2><ul><li>核心:为父类实例添加新特性，作为子类实例返回</li><li>优点<ul><li>不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果</li></ul></li><li>缺点<ul><li>实例是父类的实例，不是子类的实例</li><li>不支持多继承</li></ul></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">"son"</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h2><ul><li>核心:为父类实例添加新特性，作为子类实例返回</li><li><p>优点</p><ul><li>支持多继承</li></ul></li><li><p>缺点</p><ul><li>效率较低，内存占用高（因为要拷贝父类的属性）</li><li>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li></ul></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> p <span class="token keyword">in</span> instance<span class="token punctuation">)</span><span class="token punctuation">{</span>  Son<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> instance<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  Son<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><ul><li>核心:通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</li><li><p>优点</p><ul><li>弥补了构造继承的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li><li>既是子类的实例，也是父类的实例</li><li>不存在引用属性共享问题</li><li>可传参</li><li>函数可复用</li></ul></li><li><p>缺点</p><ul><li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li></ul></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>  Father<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Son<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><ul><li>核心:通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</li><li><p>优点</p><ul><li>堪称完美</li></ul></li><li><p>缺点</p><ul><li>实现较为复杂</li></ul></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>  Father<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建一个没有实例方法的类</span>  <span class="token keyword">var</span> Super <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  Super<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Father<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将实例作为子类的原型</span>  Son<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6对象的扩展</title>
      <link href="/2018/03/06/web/js/es/object/"/>
      <url>/2018/03/06/web/js/es/object/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="es6对于对象的扩展"><a href="#es6对于对象的扩展" class="headerlink" title="es6对于对象的扩展"></a><center>es6对于对象的扩展</center></h1><ul><li>属性名的简洁表达式</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>属性表达式  </li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>  aaa<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"bbb"</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>方法的name的属性</li><li><p>Object.is() 方法与 === 行为基本等效<br>　　== 要把值的类型自动转换  这个只是值相等<br>　　=== 类型相等,值也要相等 <code>NaN与NaN并不相等</code>   <code>+0 与 -0 相等</code><br>　　Object.is()  <code>NaN与NaN相等</code>   <code>+0与-0并不相等</code></p></li><li><p>Object.assign</p></li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 用于对象的合并 * @param {*} 目标对象 * @param {*} 后面的参数都是源对象 拷贝的是源对象的可枚举(不拷贝继承属性)的属性,如果属性相同后者会覆盖前者 * @returns 新的对象 */</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 注意:</span><span class="token comment" spellcheck="true">// 1:浅拷贝(要想深层拷贝合并可以使用lodash中_.defaultsDeep(target,souce))</span><span class="token comment" spellcheck="true">// 2:用途</span><span class="token comment" spellcheck="true">// a:为对象添加属性</span><span class="token comment" spellcheck="true">// b:为对象添加方法</span><span class="token comment" spellcheck="true">// c:克隆对象</span><span class="token comment" spellcheck="true">// d:合并多个对象</span><span class="token comment" spellcheck="true">// e:为属性指定默认值</span></code></pre><ul><li>属性的枚举和遍历</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>object</title>
      <link href="/2018/03/05/web/js/obj/object/"/>
      <url>/2018/03/05/web/js/obj/object/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="object"><a href="#object" class="headerlink" title="object"></a><center>object</center></h1><h2 id="对象特性"><a href="#对象特性" class="headerlink" title="对象特性"></a>对象特性</h2><ul><li>对象的原型(prototype)指向另外一个对象,本对象的属性继承来自它的原型对象</li><li>对象的类(class)是一个标识对象类型的字符串</li><li>对象的扩展标记(extensible flag)指明了在(es5中)是否可以向该对象添加新属性</li></ul><h2 id="三类js对象"><a href="#三类js对象" class="headerlink" title="三类js对象"></a>三类js对象</h2><ul><li>内置对象(native object)是由es规范定义的对象或类。例如:数组、函数、日期、和正则表达式</li><li>宿主对象(host object)是由js解释器所嵌入的宿主环境(也可以当成内置对象)<ul><li>HTMLElement对象</li></ul></li><li>自定义对象(user-defined object)是由运行中的js代码创建的对象</li></ul><h2 id="两类属性"><a href="#两类属性" class="headerlink" title="两类属性"></a>两类属性</h2><ul><li>自由属性(own property)是直接在对象中定义的属性</li><li>继承属性(inherited property)是在对象的原型对象中定义的属性</li></ul><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><ul><li>使用对象的直接量创建</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 用直接量创建的对象并没有prototype属性</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>通过new的方式</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 创建一个空对象和使用对象直接量一样的</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个空数组,和[]一样</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个表示当前时间的Date对象</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个可以进行模式匹配的EegExp对象</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>Object.create()</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** *  * @param {*} 第一个参数这个对象的原型 * @param {*} 第二个参数是用于对象的属性进一步描诉(可选的) */</span>Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><ul><li>object.property <code>点运算符</code> 点后面的值是<code>静态的</code></li><li>object[‘property’] <code>关联数组(散列、映射或字典)</code> 方括号里面的<code>字符串是动态的</code></li></ul><h3 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h3><ul><li>value:值</li><li>可写(writable attribute):是否可以设置该属性的值</li><li>可枚举(enumerable attribute):是否可以通过for/in循环返回该属性</li><li>可配置(configurable attribute):是否可以删除或修改该属性</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 给某个对象的多个属性赋值属性的特性,如果这个属性没有则创建,如果有则修改 * @param {*} 要在其上定义属性的对象 * @param {*} 要定义或修改的属性的名称 * @param {*} 将被定义或修改的属性描述符 * @returns 被传递给函数的对象。 */</span><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// get set 方法都能被delete方法删除</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> value <span class="token operator">+</span> <span class="token string">'a'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="检查属性"><a href="#检查属性" class="headerlink" title="检查属性"></a>检查属性</h4><ul><li>“x” <code>in</code> Obj // 返回的true或者false (<code>继承属性也要检查出来</code>)</li><li>obj.<code>hasOwnPreperty("x")</code> //  是否有自己的属性(<code>检查测不出来继承属性</code>)</li><li>obj.<code>prepertyEnumerable ("x")</code> //  是否有自己的属性并且可枚举的属性(<code>不能检查出继承属性</code>)</li></ul><h4 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h4><ul><li>Object.getOwnPropertyNames(obj) // 返回的是对象自由的属性名字结合</li></ul><h3 id="属性的删除"><a href="#属性的删除" class="headerlink" title="属性的删除"></a>属性的删除</h3><p>　　delete运算符只能删除<code>自有属性</code>;不能删除<code>那些可配置性为false的属性</code></p><h2 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h2><p>　　对象与字符串相互之间的转换 ==> <code>JSON.parse()</code> <===> <code>JSON.stringify()</code>;</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this</title>
      <link href="/2018/02/11/web/js/basics/this/"/>
      <url>/2018/02/11/web/js/basics/this/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="this的理解"><a href="#this的理解" class="headerlink" title="this的理解"></a><center>this的理解</center></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>　　this的指向是<code>再执行时才确定</code>(最后谁调用this就指向谁),并不是<code>创建时就确定的</code>.</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在非严格模式下并且在浏览器中</span><span class="token comment" spellcheck="true">/** *1:在全局变量中this指代的是window对象  a:var => 声明的变量都会被挂载到window中(例如var a = 1 当你使用a的时候实际是window.a) *2:当函数调用的时候this指向的是当前函数调用的最近的对象(如果没有上一级对象则是window对象) */</span><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> j <span class="token operator">=</span> o<span class="token punctuation">.</span>b<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>o<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用方法里面的this是指代的b对象而不是o对象</span><span class="token function">j</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里指代的this是window对象,j() 实际是window.j();是window里面来调用</span><span class="token comment" spellcheck="true">/** *    构造函数中 *    new可以改变this的指向,当前this就会赋给等号左边的变量,即变量就会拥有这个对象的所有属性 */</span><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined => 因为这个方法返回的是空对象或者是函数(函数里面没有与之对应属性);</span><span class="token comment" spellcheck="true">// 特别注意当return返回的是null(虽然也是空对象) b.user // 为b</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeof 与instanceof的区别</title>
      <link href="/2018/02/01/web/js/obj/typeof-instanceof/"/>
      <url>/2018/02/01/web/js/obj/typeof-instanceof/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="typeof、instanceof的区别"><a href="#typeof、instanceof的区别" class="headerlink" title="typeof、instanceof的区别"></a><center>typeof、instanceof的区别</center></h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>　　number,boolean,string,function,object,undefined</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>　　<code>一般判断a变量是否是b变量的实例或者子类</code></p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token string">"type"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// String</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token string">"String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object String]</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class</title>
      <link href="/2018/02/01/web/js/es/class/"/>
      <url>/2018/02/01/web/js/es/class/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a><center>Class</center></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>　　ES6的class是一种语法糖</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><ol><li><code>class类中方法以及构造器中没有逗号分隔</code></li><li><code>typeof Point  => function 是函数</code></li><li><code>Point => Point.prototype.constructor</code></li><li>类必须使用关键字<code>new</code><ol><li><code>自动调用constructor的构造方法</code></li><li><code>constructor这个方法必须有的</code></li><li><code>如果没有显式的定义,js引擎会默认添加一个空的</code></li></ol></li><li>类的所有方法都定义在类的<code>prototype</code>属性上面,包括构造方法(与ES5一致,构造器指向类的本身)<ul><li>instanceObj.constructor === Point.prototype.constructor</li><li>Point.prototype.constructor === Point</li></ul></li><li>类的内部所有定义的方法，<code>都是不可枚举的</code><ul><li><code>ES5可以获取到prototype里面的所有方法</code></li><li><code>ES5除了constructor这个属性是唯一不可枚举的</code></li></ul></li><li><code>类的属性名</code>可以采用<code>表达式</code></li><li>类的内部以及模块的内部已经采用了严格模式</li><li>constructor默认<code>return this</code>;</li><li><code>不存在变量提升</code></li></ol><h3 id="example-class"><a href="#example-class" class="headerlink" title="example(class)"></a>example(class)</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 构造器(构造方法)</span>    <span class="token comment" spellcheck="true">// this指代实例对象</span>    <span class="token comment" spellcheck="true">// 这些属性都属于实例对象自身的属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认是返回的是Point</span>    <span class="token comment" spellcheck="true">// return { // 这样的话就返回的是新的对象</span>    <span class="token comment" spellcheck="true">//   a:1,</span>    <span class="token comment" spellcheck="true">//   b:1</span>    <span class="token comment" spellcheck="true">// };</span>    <span class="token comment" spellcheck="true">// return '我是字符串'; // 这样还是返回的是this</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// class有存值函数(setter),以及取值函数(getter)设置在属性的Descriptor对象上</span>  <span class="token keyword">get</span> <span class="token function">prop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"getter"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">set</span> <span class="token function">prop</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setter: "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   *  私有方法   *  1:通过命名方法加以区别(前面加_play()一般这种就是私有方法)   *  2:将私有方法移出class模块function bar(baz) {return this.snaf = baz;}   *  3:利用Symbol值的唯一性将私有方法命名为一个Symbol值   **/</span>  <span class="token comment" spellcheck="true">// 方法定义 => 原型上的方法</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"("</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">[</span>bar<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>      <span class="token string">"利用Symbol来创建私有方法,当你导出的时候是获取不到这个值的因为导出的时候只是导出class并没有把命名的变量Symbol进行导出"</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 该static 证明是类的静态方法,只能通过类来调用,实例不能继承下来</span>  <span class="token comment" spellcheck="true">// 如果静态方法中有this,那么这个this指的是类本身,并不是实例</span>  <span class="token comment" spellcheck="true">// 静态方法可以与非静态方法重名</span>  <span class="token comment" spellcheck="true">// 静态方法可以被继承</span>  <span class="token keyword">static</span> <span class="token function">setPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> instanceObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Point<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// class有个name属性</span></code></pre><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ol><li>继承的机制<ul><li>es6:先将父类实例对象的属性和方法加到<code>this</code>上面（所以必须先调用super方法),然后再用子类的构造函数<code>修改this</code></li><li>es5:先创建子类实例,利用Father.apply(this)来继承父类的构造器  </li></ul></li><li>子类会<code>继承</code>父类的<code>静态方法</code><ul><li>可以是采用<code>extends</code>来实现继承</li></ul></li></ol><h3 id="example-extends"><a href="#example-extends" class="headerlink" title="example(extends)"></a>example(extends)</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用父类的构造器,用来新建父类的this,这里的super必须</span>    <span class="token comment" spellcheck="true">// 子类只有调用super之后才能使用this(子类实例的构建,基于父类的实例)</span>    <span class="token comment" spellcheck="true">// super作为函数 => super()只能用于子类的构造函数中,别的地方会报错</span>    <span class="token comment" spellcheck="true">// super作为对象 => 指向父类的原型对象；在静态方法中，指向父类</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apply、call、bind</title>
      <link href="/2018/01/26/web/js/obj/apply-call-bind/"/>
      <url>/2018/01/26/web/js/obj/apply-call-bind/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="apply、call、bind的用法"><a href="#apply、call、bind的用法" class="headerlink" title="apply、call、bind的用法"></a><center>apply、call、bind的用法</center></h1><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><ul><li>参数一:　改变this的指向(<code>不传参,默认指代当前环境的this</code>)</li><li>参数二:　数组,<code>但是实际的话他会以...arguments呈现(也就是说会把数组转化为参数列表)['a','b','c'] => 'a','b','c'的形式</code></li></ul><h3 id="apply的妙用"><a href="#apply的妙用" class="headerlink" title="apply的妙用"></a>apply的妙用</h3><p>　　这些方法都只是接受param1,param2,param3apply方法可以默认把数组转化为这种形式</p><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>Math<span class="token punctuation">.</span>max<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>Math<span class="token punctuation">.</span>max<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><ul><li>参数一:　改变this的指向(<code>不传参,默认指代当前环境的this</code>)</li><li>参数二:　(a,b,c)</li></ul><h2 id="bing"><a href="#bing" class="headerlink" title="bing"></a>bing</h2><ul><li>bind(this,’1’):　 创建一个新函数，称为<code>绑定函数</code></li><li>参数一:　改变this的指向(<code>不传参,默认指代当前环境的this</code>)</li><li>参数二:　(a,b,c)</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>第一个参数都是<code>this要指向的对象</code>，也就是想指定的上下文；</li><li><code>用来改变函数的this对象的指向的</code>；</li><li><code>利用后续参数传参</code>；</li></ul><h3 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h3><ul><li>bind 是<code>返回对应函数</code>，便于稍后调用；apply 、call 则是<code>立即调用</code> 。</li></ul><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">People</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> grade<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// People.apply(this,arguments);  </span>  <span class="token comment" spellcheck="true">// 这里使用apply就会导致赋值错误因为people对应的参数位置与student对应的参数位置不一致就会导致赋值错误</span>  <span class="token comment" spellcheck="true">// 这里应该使用call</span>  People<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"shenah"</span><span class="token punctuation">,</span> <span class="token string">"18"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="/2018/01/20/web/js/basics/fang-dou-yu-jie-liu/"/>
      <url>/2018/01/20/web/js/basics/fang-dou-yu-jie-liu/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a><center>防抖与节流</center></h1><h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><p>　　<code>当持续触发事件时,一定事件段内没有再触发事件,事件处理函数才会执行一次,如果设定的时间到来之前,又一次触发事件,就重新开始延时</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h2><p>　　<code>函数的节流(throttle):当持续触发事件时,保证在一定时间段内只调用一次事件处理函数</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> throttle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> prev <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> prev <span class="token operator">>=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>      prev <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>　　函数节流<code>不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数</code>，而函数防抖<code>只是在最后一次事件后才触发一次函数</code>。比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>函数防抖:表单多次提交、表单组件内容验证</li><li>函数节流:滚动加载</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件轮询</title>
      <link href="/2018/01/14/web/js/basics/shi-jian-lun-xun/"/>
      <url>/2018/01/14/web/js/basics/shi-jian-lun-xun/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a><center>事件轮询</center></h1><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>　　主线程从<code>任务队列</code>中读取事件，这个过程是循环不断的。</p><p>　　所有任务都可以分为:<code>同步任务(都在主线程)</code>与<code>异步任务(任务队列中)</code>。</p><h2 id="运行的机制"><a href="#运行的机制" class="headerlink" title="运行的机制"></a>运行的机制</h2><ol><li><p><code>所有同步任务都在主线程上执行</code>，形成一个执行栈(每执行一条代码，向栈中压入这条代码)。</p></li><li><p><code>主线程之外，还存在一个"任务队列"。存放异步执行的代码，如定时器、事件监听回调函数等，进入等待状态</code>。</p></li><li><p>一旦主线程中的所有同步任务执行完毕，就会读取”任务队列”，看看里面有哪些任务。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p></li><li><p><code>主线程不断重复上面的第三步（轮询）</code>。</p></li></ol><h2 id="主线程与任务列表的示意图"><a href="#主线程与任务列表的示意图" class="headerlink" title="主线程与任务列表的示意图"></a>主线程与任务列表的示意图</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shenanheng/pictureManage/master/blog/markdown/task-queue.png" alt="主线程与任务列表"></p><p><code>任务队列:执行的是先进先出</code>。</p><h2 id="Event-Loop-事件轮询"><a href="#Event-Loop-事件轮询" class="headerlink" title="Event Loop(事件轮询)"></a>Event Loop(事件轮询)</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shenanheng/pictureManage/master/blog/markdown/event-loop.png" alt="事件轮询示意图"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件</title>
      <link href="/2018/01/06/web/js/basics/shi-jian/"/>
      <url>/2018/01/06/web/js/basics/shi-jian/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a><center>事件</center></h1><h2 id="事件中的名词"><a href="#事件中的名词" class="headerlink" title="事件中的名词"></a>事件中的名词</h2><ul><li>事件目标(event target)：<code>发生的事件或与之相关的对象</code>(常见window,document,element)  </li><li>事件类型(event type)：<code>什么类型事件的字符串</code>(click,blur)</li><li>事件处理程序或事件监听程序：<code>处理或响应事件的函数</code></li><li>事件对象(event object)：特定事件相关且包含有关该事件详细信息的对象(<code>作为参数传递给处理程序的函数</code>)</li><li>事件传播:<code>(单个对象的特定事件(window对象的load事件),必须是不能传播的)</code><br>  a:事件的捕获(常用与处理鼠标的拖放)(<code>在target本身上注册的捕获处理事件不会被调用</code>)<br>  b:事件的冒泡</li></ul><h2 id="注册事件处理程序的三种方式"><a href="#注册事件处理程序的三种方式" class="headerlink" title="注册事件处理程序的三种方式"></a>注册事件处理程序的三种方式</h2><ul><li>js对象属性为事件处理程序</li></ul><pre class=" language-js"><code class="language-js">  target<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>设置html标签属性为事件处理程序</li></ul><pre class=" language-html">  <div onclick="send()"><code class="language-html">  <div onclick="send()"></div></code></pre><ul><li>采用事件监听的形式</li></ul><pre class=" language-js"><code class="language-js">  <span class="token comment" spellcheck="true">/**   * type:事件类型   * callback:事件处理程序   * boolean:事件传播(true => 捕获; false => 冒泡) 默认值为false   */</span>  <span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>callback<span class="token punctuation">,</span>boolean<span class="token punctuation">)</span></code></pre><h2 id="事件的调用顺序"><a href="#事件的调用顺序" class="headerlink" title="事件的调用顺序"></a>事件的调用顺序</h2><ul><li>通过<code>设置对象的属性或者html属性注册的处理程序</code>一直优先调用</li><li>使用<code>addEventListener</code>注册处理程序按照它们<code>注册的顺序进行调用</code></li><li>使用<code>attachEvent()</code>可能按照<code>顺序进行调用</code>(<code>Ie8以及以前的版本才有attachEvent</code>)</li></ul><h2 id="事件相关的方法"><a href="#事件相关的方法" class="headerlink" title="事件相关的方法"></a>事件相关的方法</h2><pre class=" language-js"><code class="language-js">event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻止事件的默认行为(例如:点击超链接有跳转的行为使用这个方法就可以阻止跳转)</span></code></pre><pre class=" language-js"><code class="language-js">event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻止事件的传播</span></code></pre><h2 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h2><h3 id="1-捕获阶段"><a href="#1-捕获阶段" class="headerlink" title="1. 捕获阶段"></a>1. 捕获阶段</h3><pre><code>事件从根节点流向目标节点，途中流经各个DOM节点，在各个节点上触发捕获事件，直到达到目标点。</code></pre><h3 id="2-目标阶段"><a href="#2-目标阶段" class="headerlink" title="2. 目标阶段"></a>2. 目标阶段</h3><pre><code>事件到达目标节点时，就到了目标阶段，事件在目标节点上被触发</code></pre><h3 id="3-冒泡阶段"><a href="#3-冒泡阶段" class="headerlink" title="3. 冒泡阶段"></a>3. 冒泡阶段</h3><pre><code>事件在目标节点上触发后，不会终止，一层层向上冒，回溯到根节点。</code></pre><h4 id="事件的委托-解决事件处理程序过多"><a href="#事件的委托-解决事件处理程序过多" class="headerlink" title="事件的委托(解决事件处理程序过多)"></a>事件的委托(解决事件处理程序过多)</h4><ul><li><code>可以优化性能并且</code></li><li><code>添加进来的元素也可以绑定事件</code></li><li><code>一般在冒泡中使用</code>(冒泡兼容所有的主流的浏览器)</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
