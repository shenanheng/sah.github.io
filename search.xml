<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>object</title>
      <link href="/2018/03/05/web/js/object/"/>
      <url>/2018/03/05/web/js/object/</url>
      
        <content type="html"><![CDATA[<h1 id="object"><a href="#object" class="headerlink" title="object"></a><center>object</center></h1><h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><ul><li>可写(writable attribute):是否可以设置该属性的值</li><li>可枚举(enumerable attribute):是否可以通过for/in循环返回该属性</li><li>可配置(configurable attribute):是否可以删除或修改该属性</li></ul><h2 id="对象特性"><a href="#对象特性" class="headerlink" title="对象特性"></a>对象特性</h2><ul><li>对象的原型(prototype)指向另外一个对象,本对象的属性继承来自它的原型对象</li><li>对象的类(class)是一个标识对象类型的字符串</li><li>对象的扩展标记(extensible flag)指明了在(es5中)是否可以向该对象添加新属性</li></ul><h2 id="三类js对象"><a href="#三类js对象" class="headerlink" title="三类js对象"></a>三类js对象</h2><ul><li>内置对象(native object)是由es规范定义的对象或类。例如:数组、函数、日期、和正则表达式</li><li>宿主对象(host object)是由js解释器所嵌入的宿主环境(也可以当成内置对象)<ul><li>HTMLElement对象</li></ul></li><li>自定义对象(user-defined object)是由运行中的js代码创建的对象</li></ul><h2 id="两类属性"><a href="#两类属性" class="headerlink" title="两类属性"></a>两类属性</h2><ul><li>自由属性(own property)是直接在对象中定义的属性</li><li>继承属性(inherited property)是在对象的原型对象中定义的属性</li></ul><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><ul><li>使用对象的直接量创建</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 用直接量创建的对象并没有prototype属性</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>通过new的方式</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 创建一个空对象和使用对象直接量一样的</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个空数组,和[]一样</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个表示当前时间的Date对象</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个可以进行模式匹配的EegExp对象</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this</title>
      <link href="/2018/02/11/web/js/this/"/>
      <url>/2018/02/11/web/js/this/</url>
      
        <content type="html"><![CDATA[<h1 id="this的理解"><a href="#this的理解" class="headerlink" title="this的理解"></a><center>this的理解</center></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>　　this的指向是<code>再执行时才确定</code>(最后谁调用this就指向谁),并不是<code>创建时就确定的</code>.</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在非严格模式下并且在浏览器中</span><span class="token comment" spellcheck="true">/** *1:在全局变量中this指代的是window对象  a:var => 声明的变量都会被挂载到window中(例如var a = 1 当你使用a的时候实际是window.a) *2:当函数调用的时候this指向的是当前函数调用的最近的对象(如果没有上一级对象则是window对象) */</span><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> j <span class="token operator">=</span> o<span class="token punctuation">.</span>b<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>o<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用方法里面的this是指代的b对象而不是o对象</span><span class="token function">j</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里指代的this是window对象,j() 实际是window.j();是window里面来调用</span><span class="token comment" spellcheck="true">/** *    构造函数中 *    new可以改变this的指向,当前this就会赋给等号左边的变量,即变量就会拥有这个对象的所有属性 */</span><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined => 因为这个方法返回的是空对象或者是函数(函数里面没有与之对应属性);</span><span class="token comment" spellcheck="true">// 特别注意当return返回的是null(虽然也是空对象) b.user // 为b</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeof 与instanceof的区别</title>
      <link href="/2018/02/01/web/js/typeof-instanceof/"/>
      <url>/2018/02/01/web/js/typeof-instanceof/</url>
      
        <content type="html"><![CDATA[<h1 id="typeof、instanceof的区别"><a href="#typeof、instanceof的区别" class="headerlink" title="typeof、instanceof的区别"></a><center>typeof、instanceof的区别</center></h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>　　number,boolean,string,function,object,undefined</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>　　<code>一般判断a变量是否是b变量的实例或者子类</code></p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token string">"type"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// String</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token string">"String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object String]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class</title>
      <link href="/2018/02/01/web/es/class/"/>
      <url>/2018/02/01/web/es/class/</url>
      
        <content type="html"><![CDATA[<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a><center>Class</center></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>　　ES6的class是一种语法糖</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><ol><li><code>class类中方法以及构造器中没有逗号分隔</code></li><li><code>typeof Point  =&gt; function 是函数</code></li><li><code>Point =&gt; Point.prototype.constructor</code></li><li>类必须使用关键字<code>new</code><ol><li><code>自动调用constructor的构造方法</code></li><li><code>constructor这个方法必须有的</code></li><li><code>如果没有显式的定义,js引擎会默认添加一个空的</code></li></ol></li><li>类的所有方法都定义在类的<code>prototype</code>属性上面,包括构造方法(与ES5一致,构造器指向类的本身)<ul><li>instanceObj.constructor === Point.prototype.constructor</li><li>Point.prototype.constructor === Point</li></ul></li><li>类的内部所有定义的方法，<code>都是不可枚举的</code><ul><li><code>ES5可以获取到prototype里面的所有方法</code></li><li><code>ES5除了constructor这个属性是唯一不可枚举的</code></li></ul></li><li><code>类的属性名</code>可以采用<code>表达式</code></li><li>类的内部以及模块的内部已经采用了严格模式</li><li>constructor默认<code>return this</code>;</li><li><code>不存在变量提升</code></li></ol><h3 id="example-class"><a href="#example-class" class="headerlink" title="example(class)"></a>example(class)</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 构造器(构造方法)</span>    <span class="token comment" spellcheck="true">// this指代实例对象</span>    <span class="token comment" spellcheck="true">// 这些属性都属于实例对象自身的属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认是返回的是Point</span>    <span class="token comment" spellcheck="true">// return { // 这样的话就返回的是新的对象</span>    <span class="token comment" spellcheck="true">//   a:1,</span>    <span class="token comment" spellcheck="true">//   b:1</span>    <span class="token comment" spellcheck="true">// };</span>    <span class="token comment" spellcheck="true">// return '我是字符串'; // 这样还是返回的是this</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// class有存值函数(setter),以及取值函数(getter)设置在属性的Descriptor对象上</span>  <span class="token keyword">get</span> <span class="token function">prop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"getter"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">set</span> <span class="token function">prop</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setter: "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   *  私有方法   *  1:通过命名方法加以区别(前面加_play()一般这种就是私有方法)   *  2:将私有方法移出class模块function bar(baz) {return this.snaf = baz;}   *  3:利用Symbol值的唯一性将私有方法命名为一个Symbol值   **/</span>  <span class="token comment" spellcheck="true">// 方法定义 => 原型上的方法</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"("</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">[</span>bar<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>      <span class="token string">"利用Symbol来创建私有方法,当你导出的时候是获取不到这个值的因为导出的时候只是导出class并没有把命名的变量Symbol进行导出"</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 该static 证明是类的静态方法,只能通过类来调用,实例不能继承下来</span>  <span class="token comment" spellcheck="true">// 如果静态方法中有this,那么这个this指的是类本身,并不是实例</span>  <span class="token comment" spellcheck="true">// 静态方法可以与非静态方法重名</span>  <span class="token comment" spellcheck="true">// 静态方法可以被继承</span>  <span class="token keyword">static</span> <span class="token function">setPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> instanceObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Point<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// class有个name属性</span></code></pre><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ol><li>继承的机制<ul><li>es6:先将父类实例对象的属性和方法加到<code>this</code>上面（所以必须先调用super方法),然后再用子类的构造函数<code>修改this</code></li><li>es5:先创建子类实例,利用Father.apply(this)来继承父类的构造器  </li></ul></li><li>子类会<code>继承</code>父类的<code>静态方法</code><ul><li>可以是采用<code>extends</code>来实现继承</li></ul></li></ol><h3 id="example-extends"><a href="#example-extends" class="headerlink" title="example(extends)"></a>example(extends)</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用父类的构造器,用来新建父类的this,这里的super必须</span>    <span class="token comment" spellcheck="true">// 子类只有调用super之后才能使用this(子类实例的构建,基于父类的实例)</span>    <span class="token comment" spellcheck="true">// super作为函数 => super()只能用于子类的构造函数中,别的地方会报错</span>    <span class="token comment" spellcheck="true">// super作为对象 => 指向父类的原型对象；在静态方法中，指向父类</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apply、call、bind</title>
      <link href="/2018/01/26/web/js/apply-call-bind/"/>
      <url>/2018/01/26/web/js/apply-call-bind/</url>
      
        <content type="html"><![CDATA[<h1 id="apply、call、bind的用法"><a href="#apply、call、bind的用法" class="headerlink" title="apply、call、bind的用法"></a><center>apply、call、bind的用法</center></h1><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><ul><li>参数一:　改变this的指向(<code>不传参,默认指代当前环境的this</code>)</li><li>参数二:　数组,<code>但是实际的话他会以...arguments呈现(也就是说会把数组转化为参数列表)[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] =&gt; &#39;a&#39;,&#39;b&#39;,&#39;c&#39;的形式</code></li></ul><h3 id="apply的妙用"><a href="#apply的妙用" class="headerlink" title="apply的妙用"></a>apply的妙用</h3><p>　　这些方法都只是接受param1,param2,param3apply方法可以默认把数组转化为这种形式</p><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>Math<span class="token punctuation">.</span>max<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>Math<span class="token punctuation">.</span>max<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><ul><li>参数一:　改变this的指向(<code>不传参,默认指代当前环境的this</code>)</li><li>参数二:　(a,b,c)</li></ul><h2 id="bing"><a href="#bing" class="headerlink" title="bing"></a>bing</h2><ul><li>bind(this,’1’):　 创建一个新函数，称为<code>绑定函数</code></li><li>参数一:　改变this的指向(<code>不传参,默认指代当前环境的this</code>)</li><li>参数二:　(a,b,c)</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>第一个参数都是<code>this要指向的对象</code>，也就是想指定的上下文；</li><li><code>用来改变函数的this对象的指向的</code>；</li><li><code>利用后续参数传参</code>；</li></ul><h3 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h3><ul><li>bind 是<code>返回对应函数</code>，便于稍后调用；apply 、call 则是<code>立即调用</code> 。</li></ul><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">People</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> grade<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// People.apply(this,arguments);  </span>  <span class="token comment" spellcheck="true">// 这里使用apply就会导致赋值错误因为people对应的参数位置与student对应的参数位置不一致就会导致赋值错误</span>  <span class="token comment" spellcheck="true">// 这里应该使用call</span>  People<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"shenah"</span><span class="token punctuation">,</span> <span class="token string">"18"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="/2018/01/20/web/js/fang-dou-yu-jie-liu/"/>
      <url>/2018/01/20/web/js/fang-dou-yu-jie-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a><center>防抖与节流</center></h1><h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><p>　　<code>当持续触发事件时,一定事件段内没有再触发事件,事件处理函数才会执行一次,如果设定的时间到来之前,又一次触发事件,就重新开始延时</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h2><p>　　<code>函数的节流(throttle):当持续触发事件时,保证在一定时间段内只调用一次事件处理函数</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> throttle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> prev <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> prev <span class="token operator">>=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>      prev <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>　　函数节流<code>不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数</code>，而函数防抖<code>只是在最后一次事件后才触发一次函数</code>。比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>函数防抖:表单多次提交、表单组件内容验证</li><li>函数节流:滚动加载</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件轮询</title>
      <link href="/2018/01/14/web/js/shi-jian-lun-xun/"/>
      <url>/2018/01/14/web/js/shi-jian-lun-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a><center>事件轮询</center></h1><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>　　主线程从<code>任务队列</code>中读取事件，这个过程是循环不断的。</p><p>　　所有任务都可以分为:<code>同步任务(都在主线程)</code>与<code>异步任务(任务队列中)</code>。</p><h2 id="运行的机制"><a href="#运行的机制" class="headerlink" title="运行的机制"></a>运行的机制</h2><ol><li><p><code>所有同步任务都在主线程上执行</code>，形成一个执行栈(每执行一条代码，向栈中压入这条代码)。</p></li><li><p><code>主线程之外，还存在一个&quot;任务队列&quot;。存放异步执行的代码，如定时器、事件监听回调函数等，进入等待状态</code>。</p></li><li><p>一旦主线程中的所有同步任务执行完毕，就会读取”任务队列”，看看里面有哪些任务。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p></li><li><p><code>主线程不断重复上面的第三步（轮询）</code>。</p></li></ol><h2 id="主线程与任务列表的示意图"><a href="#主线程与任务列表的示意图" class="headerlink" title="主线程与任务列表的示意图"></a>主线程与任务列表的示意图</h2><p><img src="/imgs/task-queue.png" alt="主线程与任务列表"></p><p><code>任务队列:执行的是先进先出</code>。</p><h2 id="Event-Loop-事件轮询"><a href="#Event-Loop-事件轮询" class="headerlink" title="Event Loop(事件轮询)"></a>Event Loop(事件轮询)</h2><p><img src="/imgs/event-loop.png" alt="事件轮询示意图"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件</title>
      <link href="/2018/01/06/web/js/shi-jian/"/>
      <url>/2018/01/06/web/js/shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a><center>事件</center></h1><h2 id="事件中的名词"><a href="#事件中的名词" class="headerlink" title="事件中的名词"></a>事件中的名词</h2><ul><li>事件目标(event target)：<code>发生的事件或与之相关的对象</code>(常见window,document,element)  </li><li>事件类型(event type)：<code>什么类型事件的字符串</code>(click,blur)</li><li>事件处理程序或事件监听程序：<code>处理或响应事件的函数</code></li><li>事件对象(event object)：特定事件相关且包含有关该事件详细信息的对象(<code>作为参数传递给处理程序的函数</code>)</li><li>事件传播:<code>(单个对象的特定事件(window对象的load事件),必须是不能传播的)</code><br>  a:事件的捕获(常用与处理鼠标的拖放)(<code>在target本身上注册的捕获处理事件不会被调用</code>)<br>  b:事件的冒泡</li></ul><h2 id="注册事件处理程序的三种方式"><a href="#注册事件处理程序的三种方式" class="headerlink" title="注册事件处理程序的三种方式"></a>注册事件处理程序的三种方式</h2><ul><li>js对象属性为事件处理程序</li></ul><pre class=" language-js"><code class="language-js">  target<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>设置html标签属性为事件处理程序</li></ul><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>send()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><ul><li>采用事件监听的形式</li></ul><pre class=" language-js"><code class="language-js">  <span class="token comment" spellcheck="true">/**   * type:事件类型   * callback:事件处理程序   * boolean:事件传播(true => 捕获; false => 冒泡) 默认值为false   */</span>  <span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>callback<span class="token punctuation">,</span>boolean<span class="token punctuation">)</span></code></pre><h2 id="事件的调用顺序"><a href="#事件的调用顺序" class="headerlink" title="事件的调用顺序"></a>事件的调用顺序</h2><ul><li>通过<code>设置对象的属性或者html属性注册的处理程序</code>一直优先调用</li><li>使用<code>addEventListener</code>注册处理程序按照它们<code>注册的顺序进行调用</code></li><li>使用<code>attachEvent()</code>可能按照<code>顺序进行调用</code>(<code>Ie8以及以前的版本才有attachEvent</code>)</li></ul><h2 id="事件相关的方法"><a href="#事件相关的方法" class="headerlink" title="事件相关的方法"></a>事件相关的方法</h2><pre class=" language-js"><code class="language-js">event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻止事件的默认行为(例如:点击超链接有跳转的行为使用这个方法就可以阻止跳转)</span></code></pre><pre class=" language-js"><code class="language-js">event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻止事件的传播</span></code></pre><h2 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h2><h3 id="1-捕获阶段"><a href="#1-捕获阶段" class="headerlink" title="1. 捕获阶段"></a>1. 捕获阶段</h3><pre><code>事件从根节点流向目标节点，途中流经各个DOM节点，在各个节点上触发捕获事件，直到达到目标点。</code></pre><h3 id="2-目标阶段"><a href="#2-目标阶段" class="headerlink" title="2. 目标阶段"></a>2. 目标阶段</h3><pre><code>事件到达目标节点时，就到了目标阶段，事件在目标节点上被触发</code></pre><h3 id="3-冒泡阶段"><a href="#3-冒泡阶段" class="headerlink" title="3. 冒泡阶段"></a>3. 冒泡阶段</h3><pre><code>事件在目标节点上触发后，不会终止，一层层向上冒，回溯到根节点。</code></pre><h4 id="事件的委托-解决事件处理程序过多"><a href="#事件的委托-解决事件处理程序过多" class="headerlink" title="事件的委托(解决事件处理程序过多)"></a>事件的委托(解决事件处理程序过多)</h4><ul><li><code>可以优化性能并且</code></li><li><code>添加进来的元素也可以绑定事件</code></li><li><code>一般在冒泡中使用</code>(冒泡兼容所有的主流的浏览器)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
